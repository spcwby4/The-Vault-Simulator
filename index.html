<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>The Vault Simulator</title>
  <style>
    :root{
      --bg:#0f1115;
      --panel:#1a1d24;
      --muted:#2a2f3a;
      --text:#e5e7eb;
      --sub:#aeb4c0;
      --accent:#7aa2ff;
      --good:#6ee7b7;
      --warn:#fbbf24;
      --bad:#f87171;
      --border:#2b3340;
    }
    *{box-sizing:border-box}
    body{font-family:Arial,Helvetica,sans-serif;background:var(--bg);color:var(--text);padding:20px;margin:0}
    h1{margin:0 0 16px;text-align:center}
    h2{margin:0 0 10px;font-size:18px;color:var(--text)}
    textarea,button,input{width:100%;padding:10px;margin-top:10px;font-size:15px;border-radius:8px;border:1px solid var(--border);background:var(--panel);color:var(--text)}
    button{cursor:pointer}
    button:hover{background:var(--muted)}
    .box{background:var(--panel);padding:15px;border-radius:12px;box-shadow:0 0 0 1px var(--border);margin-bottom:18px}
    pre{background:var(--bg);padding:10px;border-radius:8px;height:220px;overflow-y:auto;border:1px solid var(--border);white-space:pre-wrap}
    table{width:100%;border-collapse:collapse;margin-top:10px}
    th,td{border:1px solid var(--border);padding:8px;text-align:center;white-space:nowrap}
    th{background:var(--muted);position:sticky;top:0}
    .pill{display:inline-block;min-width:20px;border-radius:6px;padding:2px 6px}
    .ok{background:rgba(110,231,183,.15);border:1px solid rgba(110,231,183,.35)}
    .no{background:rgba(248,113,113,.12);border:1px solid rgba(248,113,113,.3)}
    .flex{display:flex;gap:18px;flex-wrap:wrap}
    .half{flex:1 1 420px}
    .right{max-width:520px}
    .hint{color:var(--sub);font-size:13px;margin-top:6px}
    .badge{display:inline-block;padding:2px 6px;border-radius:6px;background:var(--muted);font-size:12px;margin-left:6px}
    .table-scroll{overflow:auto;max-width:100%}
    .stats-input{width:70px}
    .rowwrap{display:flex;gap:18px;flex-wrap:wrap}
    .third{flex:1 1 340px}
  </style>
</head>
<body>

  <h1>The Vault Simulator <span class="badge">Dark</span></h1>

  <div class="box">
    <label for="playerInput"><strong>Enter 12 Players (one per line):</strong></label>
    <textarea id="playerInput" rows="12" placeholder="Player 1&#10;Player 2&#10;..."></textarea>
    <button id="startBtn">Start Game</button>
    <button id="nextBtn" style="display:none;">Next</button>
    <div class="hint">Flow: Phase 1 → Phase 2 → Phase 3 (vote step, then duel step) → Finale (Jury → Open → Winner).</div>
  </div>

  <div class="rowwrap">
    <div class="box third" id="statsBox">
      <h2>Player Stats (Preseason)</h2>
      <div id="statsTable"></div>
      <div class="rowwrap">
        <button id="presetBalanced" class="third">Balanced</button>
        <button id="presetSocial" class="third">Social‑heavy</button>
        <button id="presetChallenge" class="third">Challenge‑heavy</button>
      </div>
      <button id="applyStats">Apply Stats</button>
      <div class="hint">Range: 1–15. Defaults to 8/8. Stats lock after you click Start Game.</div>
    </div>

    <div class="box third">
      <h2>Round Events</h2>
      <pre id="roundEvents"></pre>
    </div>

    <div class="box third right">
      <h2>Alliances</h2>
      <div id="alliancesList"></div>
    </div>
  </div>

  <div class="box">
    <h2>Progress Chart</h2>
    <div id="progressChart"></div>
  </div>

  <div class="box">
    <h2>Voting Matrix (Season)</h2>
    <div class="table-scroll" id="votingMatrix"></div>
    <div class="hint">Plain text. LOCKPICK appears in the voter’s cell if used that round. Eliminated voters are kept and reordered: active/finalists, then Phase 3 eliminated, Phase 2 eliminated, Phase 1 eliminated.</div>
  </div>

  <div class="box">
    <h2>Jury Key Distribution</h2>
    <div id="juryMatrix"></div>
  </div>

<script>
/* ====== Tunables ====== */
const ALPHA_SOCIAL = 1.0;   // vote weighting by Social
const BETA_CHALLENGE = 1.0; // P1 challenge weighting
const GAMMA_BEATABLE = 1.2; // opponent selection inverse challenge exponent
const LOGIT_K = 0.7;        // duel steepness
const WIN_CLAMP_LO = 0.15;  // min duel win prob
const WIN_CLAMP_HI = 0.85;  // max duel win prob

/* ====== State ====== */
let players = [];
let initialOrder = [];
let phase = 1;
let round = 1;

let alliances = {};     // {Name:[players]}
let keys = {};          // {player:[ "P1", "P2" ]}
let jury = [];          // [{name, phase}]
let finalists = [];     // [p1,p2,p3]
let eliminated = [];    // elimination order

let lockpickHolder = null;
let lockpickUsed = false;
let lockpickFound = false;

let currentDraw = [];

let voteColumns = [];   // [{label, phaseTag, roundNo, result, values:{voter:value}}]
let knownVoters = [];
let vaults = [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22];

let gameStarted = false;
let phase3Step = 0; // 0 vote+ally, 1 duel

// Finale staged
let finaleStep = 0; // 0 jury awards, 1 open vaults, 2 reveal winner
let finaleState = {
  finalistKeys: null,
  chosenVaults: null,
  juryMatrix: null,
  resultList: null,
  winner: null,
};

// Stats
let stats = {}; // { name: {social:8, challenge:8} }

/* ====== DOM ====== */
const startBtn = document.getElementById('startBtn');
const nextBtn  = document.getElementById('nextBtn');
const roundsBox= document.getElementById('roundEvents');
const statsBox = document.getElementById('statsBox');
const statsTableDiv = document.getElementById('statsTable');

document.getElementById('applyStats').onclick = applyStatsFromInputs;
document.getElementById('presetBalanced').onclick = ()=>presetStats('balanced');
document.getElementById('presetSocial').onclick   = ()=>presetStats('social');
document.getElementById('presetChallenge').onclick= ()=>presetStats('challenge');

startBtn.onclick = startGame;
nextBtn.onclick  = nextRound;

/* ====== Helpers ====== */
function log(msg){
  roundsBox.textContent += (roundsBox.textContent ? '\n' : '') + msg;
  roundsBox.scrollTop = roundsBox.scrollHeight;
}
function clearLog(){ roundsBox.textContent = '' }
function shuffle(arr){ return arr.slice().sort(()=>Math.random()-0.5) }
function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)) }

function inAlliance(a,b){
  return Object.values(alliances).some(list => list.includes(a) && list.includes(b));
}
function getElimPhase(name){ const j = jury.find(x=>x.name===name); return j ? j.phase : null }

/* Weighted helpers */
function weightedChoice(items, weightFn){
  const weights = items.map(x => Math.max(0.0001, weightFn(x)));
  const sum = weights.reduce((a,b)=>a+b,0);
  let r = Math.random()*sum;
  for(let i=0;i<items.length;i++){
    if((r -= weights[i]) <= 0) return items[i];
  }
  return items[items.length-1];
}
function duelWinProb(a,b){
  // logistic on Challenge diff
  const da = stats[a]?.challenge ?? 8;
  const db = stats[b]?.challenge ?? 8;
  const p = 1 / (1 + Math.exp(-LOGIT_K * (da - db)));
  return clamp(p, WIN_CLAMP_LO, WIN_CLAMP_HI);
}

/* ====== Start / Next / Reset ====== */
function startGame(){
  if(gameStarted) return;
  const input = document.getElementById('playerInput').value.trim().split('\n').map(s=>s.trim()).filter(Boolean);
  if(input.length !== 12){ alert('Please enter exactly 12 players.'); return }
  gameStarted = true;

  players = input;
  initialOrder = input.slice();
  knownVoters = input.slice();
  players.forEach(p => keys[p] = []);

  // Default stats 8/8 if not set
  players.forEach(p=>{
    if(!stats[p]) stats[p] = {social:8, challenge:8};
  });

  // Lock the stats UI
  statsBox.style.display = 'none';

  generateAlliances();
  updateAlliances();
  updateProgress();
  renderMasterVoteTable();

  log('Phase 1 begins: The Key Quest starts now.');
  startBtn.style.display = 'none';
  nextBtn.style.display = 'inline-block';
  nextBtn.textContent = 'Next';
  nextBtn.onclick = nextRound;

  nextRound();
}

function nextRound(){
  clearLog();
  if(phase === 1) runPhase1();
  else if(phase === 2) runPhase2();
  else if(phase === 3) runPhase3();
  else if(phase === 4) runFinale();
}

function endGameUI(){
  nextBtn.textContent = 'Simulate Again';
  nextBtn.onclick = ()=>location.reload();
}

/* ====== Stats UI ====== */
function buildStatsTable(){
  const vals = getPlist();
  let html = `<div class="table-scroll"><table>
    <tr><th>Player</th><th>Social</th><th>Challenge</th></tr>`;
  vals.forEach(name=>{
    const s = stats[name]?.social ?? 8;
    const c = stats[name]?.challenge ?? 8;
    html += `<tr>
      <td>${name}</td>
      <td><input class="stats-input" type="number" min="1" max="15" value="${s}" data-name="${name}" data-field="social"></td>
      <td><input class="stats-input" type="number" min="1" max="15" value="${c}" data-name="${name}" data-field="challenge"></td>
    </tr>`;
  });
  html += `</table></div>`;
  statsTableDiv.innerHTML = html;
}
function getPlist(){
  const input = document.getElementById('playerInput').value.trim().split('\n').map(s=>s.trim()).filter(Boolean);
  return input.length ? input : Object.keys(stats);
}
function applyStatsFromInputs(){
  const inputs = statsTableDiv.querySelectorAll('input.stats-input');
  inputs.forEach(inp=>{
    const name = inp.getAttribute('data-name');
    const field= inp.getAttribute('data-field');
    const v = clamp(parseInt(inp.value||'8',10), 1, 15);
    if(!stats[name]) stats[name] = {social:8, challenge:8};
    stats[name][field] = v;
  });
  log('Preseason stats applied.');
}
function presetStats(which){
  const names = getPlist();
  names.forEach(n=>{
    if(!stats[n]) stats[n] = {social:8, challenge:8};
    if(which==='balanced'){ stats[n].social = 8; stats[n].challenge = 8; }
    if(which==='social'){ stats[n].social = 12; stats[n].challenge = 8; }
    if(which==='challenge'){ stats[n].social = 8; stats[n].challenge = 12; }
  });
  buildStatsTable();
}

/* Render initial empty stats table */
buildStatsTable();

/* ====== Voting Core (secret, Social‑weighted) ====== */
function simulateVote(voters, eligible){
  return voters.map(v=>{
    const choices = eligible.filter(p=>p!==v);
    const allyChoices = choices.filter(c=>inAlliance(v,c));
    if(allyChoices.length){
      const pick = weightedChoice(allyChoices, cand => Math.pow((stats[cand]?.social ?? 8), ALPHA_SOCIAL));
      return [v, pick];
    }else{
      const pick = weightedChoice(choices, cand => Math.pow((stats[cand]?.social ?? 8), 0.5*ALPHA_SOCIAL));
      return [v, pick];
    }
  });
}
function tally(votePairs, eligible){
  const counts = {}; eligible.forEach(p => counts[p]=0);
  votePairs.forEach(([_,to]) => { if(counts.hasOwnProperty(to)) counts[to]++ });
  const max = Math.max(...Object.values(counts));
  const tied = Object.keys(counts).filter(p => counts[p]===max);
  return [tied[0], tied, counts];
}

/* Season voting chart */
function addVoteColumn(label, phaseTag, roundNo, voters, votePairs, result, lockpickUser=null){
  const values = {};
  knownVoters.forEach(v => values[v] = '—');
  votePairs.forEach(([v,to]) => { values[v] = to });
  if(lockpickUser){ values[lockpickUser] = 'LOCKPICK' }
  voteColumns.push({label, phaseTag, roundNo, result, values});
  renderMasterVoteTable();
}

function renderMasterVoteTable(){
  const wrap = document.getElementById('votingMatrix');
  let html = `<div class="table-scroll"><table><thead><tr><th>Voter</th>`;
  voteColumns.forEach(c => { html += `<th>${c.label}</th>`; });
  html += `</tr></thead><tbody>`;

  // ordering: active/finalists → P3 elim → P2 elim → P1 elim
  const activeRows = players.slice();
  const elimP3 = eliminated.filter(n=>getElimPhase(n)===3);
  const elimP2 = eliminated.filter(n=>getElimPhase(n)===2);
  const elimP1 = eliminated.filter(n=>getElimPhase(n)===1);

  function renderRow(name){
    html += `<tr><td>${name}</td>`;
    voteColumns.forEach(c=>{
      html += `<td>${c.values[name] ?? '—'}</td>`;
    });
    html += `</tr>`;
  }

  activeRows.forEach(renderRow);
  elimP3.forEach(renderRow);
  elimP2.forEach(renderRow);
  elimP1.forEach(renderRow);

  // result row
  html += `<tr><th>Result</th>`;
  voteColumns.forEach(c => { html += `<th>${c.result || ''}</th>`; });
  html += `</tr>`;

  html += `</tbody></table></div>`;
  wrap.innerHTML = html;
}

/* ====== Alliances (fluid, only duel snubs cause kicks) ====== */
function generateAlliances(){
  alliances = {};
  const count = Math.floor(Math.random()*3)+2; // 2..4
  const names = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('').slice(0,count);
  const sh = shuffle(players);

  names.forEach(n => alliances[n] = []);
  sh.forEach((p,i)=> alliances[names[i%count]].push(p));

  // small chance of dual-membership at start
  players.forEach(p=>{
    if(Math.random()<0.15){
      const other = names[Math.floor(Math.random()*names.length)];
      if(!alliances[other].includes(p)) alliances[other].push(p);
    }
  });
}

function penalizeNonAllyDuel(decider, opponent, alliesAvailable){
  if(!alliesAvailable) return;
  if(inAlliance(decider, opponent)) return; // they did pick an ally
  const decAlliances = Object.entries(alliances).filter(([_,list])=>list.includes(decider)).map(([n])=>n);
  if(!decAlliances.length) return;
  if(Math.random() < 0.5){
    const kickFrom = decAlliances[Math.floor(Math.random()*decAlliances.length)];
    const arr = alliances[kickFrom];
    const idx = arr.indexOf(decider);
    if(idx>-1){
      arr.splice(idx,1);
      log(`${decider} is removed from Alliance ${kickFrom} after snubbing allies in a duel pick.`);
      updateAlliances();
    }
  }
}

function evolveAlliancesMidgame(){
  if(Math.random()<0.25 && players.length>=4){
    const size = Math.floor(Math.random()*3)+2; // 2..4
    const cand = shuffle(players).slice(0, size);
    const newName = pickNewAllianceName();
    alliances[newName] = cand.slice();
    log(`New Alliance ${newName} forms: ${cand.join(', ')}`);
    updateAlliances();
  }
}
function pickNewAllianceName(){
  const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
  for(const c of alphabet){
    if(!alliances[c]) return c;
  }
  return 'Z'+Math.floor(Math.random()*99);
}
function updateAlliances(){
  const box = document.getElementById("alliancesList");
  box.innerHTML = '';
  Object.entries(alliances).forEach(([name, members])=>{
    const visible = members.filter(m => initialOrder.includes(m));
    if(visible.length){
      box.innerHTML += `<strong>Alliance ${name}</strong>: ${visible.join(', ')}` + '<br/>';
    }
  });
}

/* ====== Progress ====== */
function updateProgress(){
  const chart = document.getElementById('progressChart');
  const everyone = players.concat(eliminated.filter(p=>!players.includes(p)));
  let html = `<div class="table-scroll"><table>
    <tr><th>Player</th><th>P1</th><th>P2</th><th>Final</th></tr>`;
  everyone.forEach(p=>{
    const p1 = keys[p]?.includes('P1') ? `<span class="pill ok">✔</span>` : `<span class="pill no">—</span>`;
    const p2 = keys[p]?.includes('P2') ? `<span class="pill ok">✔</span>` : `<span class="pill no">—</span>`;
    const pf = finalists.includes(p)     ? `<span class="pill ok">✔</span>` : `<span class="pill no">—</span>`;
    html += `<tr><td>${p}</td><td>${p1}</td><td>${p2}</td><td>${pf}</td></tr>`;
  });
  html += `</table></div>`;
  chart.innerHTML = html;
}

/* ====== Phase 1 ====== */
function runPhase1(){
  if(round > 4 || Object.values(keys).filter(k=>k.includes('P1')).length >= 8){
    return endPhase1();
  }

  const eligible = players.filter(p=>!keys[p].includes('P1'));
  const drawn = shuffle(eligible).slice(0,4);
  currentDraw = drawn;

  log(`Phase 1 – Round ${round}`);
  log(`Drawn: ${drawn.join(', ')}`);

  // Lockpick discovery: base 33%, +1 percentage point if any drawn is a Challenge beast (>=13)
  const beastInDrawn = drawn.some(p => (stats[p]?.challenge ?? 8) >= 13);
  const findChance = 0.33 + (beastInDrawn ? 0.01 : 0);
  if(!lockpickFound && Math.random() < findChance){
    lockpickHolder = drawn[Math.floor(Math.random()*drawn.length)];
    lockpickFound = true;
    log(`${lockpickHolder} discovers the Lockpick.`);
  }

  // Secret vote among drawn, Social‑weighted
  const votePairs = simulateVote(knownVoters, drawn);
  let [voteWinner] = tally(votePairs, drawn);

  // Strategic Lockpick use in P1: must-use in R4 if holder lacks P1; small chance otherwise
  let lockUser = null;
  if(lockpickHolder && !lockpickUsed && drawn.includes(lockpickHolder)){
    const mustUse = (round===4 && !keys[lockpickHolder].includes('P1'));
    const willUse = mustUse || Math.random() < 0.2;
    if(willUse){
      voteWinner = lockpickHolder;
      lockUser = lockpickHolder;
      lockpickUsed = true;
      log(`${lockpickHolder} uses the Lockpick to override the vote.`);
    }
  }

  addVoteColumn(`P1 R${round}`, 'P1', round, knownVoters, votePairs, voteWinner, lockUser);

  // Award vote key
  keys[voteWinner].push('P1');
  log(`${voteWinner} wins the vote key.`);

  // Challenge among remaining drawn w/out P1 — weighted by Challenge^BETA
  const challengers = drawn.filter(p=>p!==voteWinner && !keys[p].includes('P1'));
  if(challengers.length>0){
    const challengeWinner = weightedChoice(challengers, p => Math.pow((stats[p]?.challenge ?? 8), BETA_CHALLENGE));
    keys[challengeWinner].push('P1');
    log(`${challengeWinner} wins the challenge key.`);
  }else{
    log(`No challenge key awarded.`);
  }

  evolveAlliancesMidgame();
  updateProgress();
  round++;
}

function endPhase1(){
  const advancing = players.filter(p=>keys[p].includes('P1'));
  const phaseOut  = players.filter(p=>!advancing.includes(p));

  phaseOut.forEach(p=>{ if(!eliminated.includes(p)) eliminated.push(p) });
  phaseOut.forEach(p=>jury.push({name:p, phase:1}));

  players = advancing;
  log(`Phase 1 complete. Eliminated: ${phaseOut.join(', ')}`);
  renderMasterVoteTable();
  round = 1; phase = 2;
  nextRound();
}

/* ====== Phase 2 ====== */
function runPhase2(){
  if(round > 4 || Object.values(keys).filter(k=>k.includes('P2')).length >= 4){
    return endPhase2();
  }

  log(`Phase 2 – Round ${round}`);
  const noKey = players.filter(p=>!keys[p].includes('P2'));
  if(noKey.length < 2){
    log('Not enough no‑key players for another duel.');
    return endPhase2();
  }

  const votePairs = simulateVote(players, noKey);
  let [voteWinner] = tally(votePairs, noKey);

  // Lockpick in P2: if holder lacks P2, often used
  let lockUser = null;
  if(lockpickHolder && !lockpickUsed && noKey.includes(lockpickHolder) && !keys[lockpickHolder].includes('P2')){
    if(Math.random() < 0.6){
      voteWinner = lockpickHolder;
      lockUser = lockpickHolder;
      lockpickUsed = true;
      log(`${lockpickHolder} uses the Lockpick to auto‑win the vote.`);
    }
  }

  addVoteColumn(`P2 R${round}`, 'P2', round, knownVoters, votePairs, voteWinner, lockUser);

  // Opponent choice — reason + stat‑influenced selection
  const candidates = noKey.filter(p=>p!==voteWinner);
  const nonAllies = candidates.filter(p=>!inAlliance(p, voteWinner));
  const allies    = candidates.filter(p=> inAlliance(p, voteWinner));

  let opponent, reason;
  let alliesAvailable = allies.length>0;

  if(nonAllies.length && Math.random()<0.65){
    // choose someone they believe they can beat: prefer lower Challenge
    opponent = weightedChoice(nonAllies, p => Math.pow(1/Math.max(1,(stats[p]?.challenge ?? 8)), GAMMA_BEATABLE));
    reason = 'chooses someone they believe they can beat';
  }else if(allies.length){
    // keep in alliance: avoid the absolute strongest ally to reduce risk of losing
    opponent = weightedChoice(allies, p => 1/Math.max(1,(stats[p]?.challenge ?? 8)));
    reason = 'keeps the key within their alliance';
  }else{
    opponent = weightedChoice(candidates, p => 1); // neutral
    reason = 'makes a neutral pick';
  }
  log(`${voteWinner} chooses to duel ${opponent} — ${reason}.`);

  // Penalize for snubbing allies
  penalizeNonAllyDuel(voteWinner, opponent, alliesAvailable);

  // Duel outcome — logistic on Challenge
  const pWin = duelWinProb(voteWinner, opponent);
  const duelWinner = Math.random() < pWin ? voteWinner : opponent;
  keys[duelWinner].push('P2');
  log(`${duelWinner} wins the duel and earns a Phase 2 key.`);

  evolveAlliancesMidgame();
  updateProgress();
  round++;
}

function endPhase2(){
  const advancing = players.filter(p=>keys[p].includes('P2'));
  const phaseOut  = players.filter(p=>!advancing.includes(p));

  phaseOut.forEach(p=>{ if(!eliminated.includes(p)) eliminated.push(p) });
  phaseOut.forEach(p=>jury.push({name:p, phase:2}));

  players = advancing;
  log(`Phase 2 complete. Eliminated: ${phaseOut.join(', ')}`);
  renderMasterVoteTable();
  round = 1; phase = 3; phase3Step = 0;
  nextRound();
}

/* ====== Phase 3 (Two-step) ====== */
let p3_voteWinner = null;
let p3_chosenAlly = null;
let p3_duelists = [];

function runPhase3(){
  if(phase3Step === 0){
    log(`Phase 3 — Final Cut: Vote step`);
    const votePairsRaw = simulateVote(players, players);
    const votePairs = votePairsRaw.map(([v,to])=>{
      if(v===to){
        const choices = players.filter(p=>p!==v);
        return [v, weightedChoice(choices, c => Math.pow((stats[c]?.social ?? 8), ALPHA_SOCIAL))];
      }
      return [v,to];
    });
    let [voteWinner] = tally(votePairs, players);
    p3_voteWinner = voteWinner;
    log(`${voteWinner} wins the vote and becomes a finalist.`);

    // Ally pick prefers high Social among allies; tiebreak by lower Challenge risk
    const available = players.filter(p=>p!==voteWinner);
    const allyOpts = available.filter(p=>inAlliance(p, voteWinner));
    const pool = (allyOpts.length ? allyOpts : available);
    p3_chosenAlly = weightedChoice(pool, p => (stats[p]?.social ?? 8) + 0.1*(16 - (stats[p]?.challenge ?? 8)));

    addVoteColumn(`P3 Vote`, 'P3', 1, knownVoters, votePairs, voteWinner, null);

    p3_duelists = players.filter(p=>p!==voteWinner && p!==p3_chosenAlly);
    log(`${voteWinner} selects ${p3_chosenAlly} to join them. Next: ${p3_duelists[0]} vs ${p3_duelists[1]} for the last spot. Click Next to resolve.`);
    finalists = [p3_voteWinner, p3_chosenAlly];
    updateProgress();
    phase3Step = 1;
    return;
  }

  if(phase3Step === 1){
    const a = p3_duelists[0], b = p3_duelists[1];
    const pWin = duelWinProb(a,b);
    const duelWinner = Math.random() < pWin ? a : b;
    const duelLoser  = p3_duelists.find(p=>p!==duelWinner);
    finalists.push(duelWinner);
    if(!eliminated.includes(duelLoser)) eliminated.push(duelLoser);
    jury.push({name:duelLoser, phase:3});
    log(`${duelWinner} wins the final duel. ${duelLoser} is eliminated and joins the jury.`);
    updateProgress();

    phase = 4;
    phase3Step = 0;
    log(`Click Next to proceed to the Vault Finale.`);
  }
}

/* ====== Finale (3 screens: Jury → Open → Winner) ====== */
function runFinale(){
  if(finaleStep === 0){
    if(!finaleState.finalistKeys){
      finaleState.finalistKeys = {};
      finalists.forEach(p => finaleState.finalistKeys[p] = 3);

      // Support score by alliances + Social nudging expected keys
      const supportScore = {};
      finalists.forEach(f=>{
        let score = 0;
        jury.forEach(j=>{
          const cap = j.phase===1?1:j.phase===2?2:4;
          if(inAlliance(j.name, f)) score += cap;
        });
        supportScore[f] = score + 0.4*(stats[f]?.social ?? 8);
      });

      const expect = {};
      const maxSupport = Math.max(1, ...Object.values(supportScore));
      finalists.forEach(f=>{
        const normalized = (supportScore[f]/maxSupport);
        expect[f] = Math.round(6 + normalized * 6); // 6..12
      });

      finaleState.chosenVaults = pickUniqueVaultsForFinalists(expect);

      // Distribute exactly 16 jury keys with alliance + Social tilt
      finaleState.juryMatrix = distributeJuryKeysExact16(finalists, jury, finaleState.finalistKeys);
    }

    log(`Vault Finale — Jury awards keys now.`);
    displayJuryMatrix(finaleState.juryMatrix);
    log(`Click Next to reveal vault openings.`);
    finaleStep = 1;
    return;
  }

  if(finaleStep === 1){
    log(`Vault selections: ${finalists.map(f=>`${f} → ${finaleState.chosenVaults[f]} keys`).join(', ')}`);
    finalists.forEach(f=>{
      log(`${f} has ${finaleState.finalistKeys[f]} total keys.`);
    });

    const result = finalists.map(name => ({
      name,
      keys: finaleState.finalistKeys[name],
      vault: finaleState.chosenVaults[name]
    })).sort((a,b)=>b.vault - a.vault);
    finaleState.resultList = result;
    finaleState.winner = result.find(r => r.keys >= r.vault) || null;

    log(`Click Next to reveal the winner.`);
    finaleStep = 2;
    return;
  }

  if(finaleStep === 2){
    if(!finaleState.winner){
      const fourth = jury.find(j=>j.phase===3)?.name || 'Fourth Place';
      log(`No finalist opened a vault. ${fourth} wins by default.`);
    }else{
      log(`${finaleState.winner.name} opens the ${finaleState.winner.vault}-key vault with ${finaleState.winner.keys} keys and wins.`);
    }
    endGameUI();
  }
}

/* Unique vaults closest to expectations, no duplicates */
function pickUniqueVaultsForFinalists(expect){
  const picked = {};
  const available = vaults.slice();
  const order = Object.keys(expect).sort((a,b)=>expect[b]-expect[a]);
  order.forEach(f=>{
    let best = available[0], bestDiff = Infinity, bestIdx = 0;
    available.forEach((v,i)=>{
      const d = Math.abs(v - expect[f]);
      if(d < bestDiff){ bestDiff = d; best = v; bestIdx = i; }
    });
    picked[f] = best;
    available.splice(bestIdx, 1);
  });
  return picked;
}

/* Jury distribution to total EXACTLY 16 keys with per-juror caps, alliance + Social tilt */
function distributeJuryKeysExact16(finalists, jury, finalistKeys){
  const capPool = [];
  jury.forEach(j=>{
    const cap = j.phase===1?1:j.phase===2?2:4;
    for(let i=0;i<cap;i++) capPool.push(j.name);
  });
  shuffle(capPool);
  const draws = capPool.slice(0,16);

  const jm = {};
  jury.forEach(j=>{ jm[j.name] = Object.fromEntries(finalists.map(f=>[f,0])) });

  function expectedSupport(f){
    let s = 0;
    jury.forEach(j=>{
      const cap = j.phase===1?1:j.phase===2?2:4;
      if(inAlliance(j.name, f)) s += cap;
    });
    // Social tilt
    s += 0.4*(stats[f]?.social ?? 8);
    return s;
  }

  draws.forEach(jName=>{
    const j = jury.find(x=>x.name===jName);
    const shared = finalists.filter(f=>inAlliance(j.name, f));
    let target;
    if(shared.length === 1){
      target = shared[0];
    }else if(shared.length === 2){
      target = Math.random()<0.6 ? finalists.slice().sort((a,b)=>expectedSupport(b)-expectedSupport(a))[0]
                                 : finalists[Math.floor(Math.random()*finalists.length)];
    }else{
      target = Math.random()<0.65 ? finalists.slice().sort((a,b)=>expectedSupport(b)-expectedSupport(a))[0]
                                  : finalists[Math.floor(Math.random()*finalists.length)];
    }
    jm[jName][target] += 1;
    finalistKeys[target] += 1;
  });

  return jm;
}

/* ====== UI: Jury Matrix ====== */
function displayJuryMatrix(matrix){
  const area = document.getElementById('juryMatrix');
  if(!finalists.length){ area.innerHTML = ''; return }
  let html = `<div class="table-scroll"><table><tr><th>Juror</th>${finalists.map(f=>`<th>${f}</th>`).join('')}<th>Total</th></tr>`;
  let totalGiven = 0;
  for(const juror in matrix){
    let sum = 0;
    html += `<tr><td>${juror}</td>`;
    finalists.forEach(f=>{
      const v = matrix[juror][f]||0;
      sum += v; totalGiven += v;
      html += `<td>${v}</td>`;
    });
    html += `<td>${sum}</td></tr>`;
  }
  html += `</table></div>`;
  html += `<div class="hint">Total jury keys distributed: <strong>${totalGiven}</strong> (should be exactly 16)</div>`;
  area.innerHTML = html;
}

/* ====== Build/refresh stats table on input changes ====== */
document.getElementById('playerInput').addEventListener('input', ()=>{
  if(!gameStarted) buildStatsTable();
});

</script>
</body>
</html>