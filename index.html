<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The Vault Simulator — Alt Rules (Full)</title>
<meta http-equiv="Content-Security-Policy" content="img-src 'self' https: data:;">
<style>
  :root { --bg:#f6f7fb; --card:#fff; --line:#e6e6e6; --muted:#6b7280; --text:#0f172a; }
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--text)}
  header{background:#fff;border-bottom:1px solid var(--line);padding:14px 18px}
  h1{margin:0;font-size:18px}
  main{max-width:1200px;margin:16px auto;padding:0 12px;display:grid;grid-template-columns:1fr 320px;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;box-shadow:0 1px 2px rgba(0,0,0,.03)}
  .card h2{margin:0;padding:10px 12px;border-bottom:1px solid var(--line);font-size:15px}
  .card .content{padding:12px}
  textarea{width:100%;min-height:120px;border:1px solid var(--line);border-radius:8px;padding:10px}
  input,select,button{font-size:14px}
  button{background:#111827;color:#fff;border:1px solid #111827;border-radius:8px;padding:8px 12px;cursor:pointer}
  button.secondary{background:#fff;color:#111827;border:1px solid var(--line)}
  .row{display:flex;gap:8px;align-items:flex-start;flex-wrap:wrap}
  .muted{color:var(--muted);font-size:12px}
  .pill{display:inline-block;border:1px solid var(--line);border-radius:999px;padding:3px 8px;margin:3px 3px 0 0;font-size:12px}
  #events .event{padding:10px 12px;border:1px solid var(--line);border-radius:10px;background:#fff;margin:8px 0}
  #events .evt-text{margin-bottom:8px;font-size:14px}
  #events .evt-images{display:flex;flex-wrap:wrap;gap:8px}
  #events .evt-images img{width:88px;height:88px;object-fit:cover;border-radius:6px}
  table{width:100%;border-collapse:collapse}
  .vm th,.vm td{border-bottom:1px solid #f0f0f0;padding:6px 8px;font-size:13px;text-align:left}
  .vm th{background:#fafafa;font-weight:600}
  .avatar{width:22px;height:22px;border-radius:4px;object-fit:cover;vertical-align:middle}
  #controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .hidden{display:none!important}
  @media(max-width:960px){main{grid-template-columns:1fr}}
</style>
</head>
<body>
<header><h1>The Vault Simulator — Alt Rules</h1></header>

<main>
  <!-- LEFT -->
  <section class="card">
    <h2>Player Setup</h2>
    <div class="content">
      <div class="row">
        <div style="flex:1">
          <label class="muted">Enter 13 players, one per line</label>
          <textarea id="playersInput" placeholder="Enter 13 names, one per line"></textarea>
        </div>
        <div style="flex:1">
          <label class="muted">Optional photo links (one per line, same order). Imgur gallery links are fine.</label>
          <textarea id="photosInput" placeholder="Optional: one image link per player"></textarea>
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="startBtn">Start Game</button>
        <button id="resetBtn" class="secondary">Reset</button>
        <span id="phaseLabel" class="muted"></span>
      </div>
    </div>
  </section>

  <section class="card">
    <h2>Round Events</h2>
    <div class="content"><div id="events"></div></div>
  </section>

  <section class="card">
    <h2>Voting Matrix (this round)</h2>
    <div class="content"><div id="voteMatrixWrap"></div></div>
  </section>

  <section class="card">
    <h2>Controls</h2>
    <div class="content">
      <div id="controls">
        <button id="nextBtn" class="hidden">Next</button>
        <button id="againBtn" class="hidden">Simulate Again</button>
      </div>
    </div>
  </section>

  <!-- RIGHT -->
  <section class="card">
    <h2>Alliances</h2>
    <div id="alliancesBox" class="content"><div class="muted">Generated at start. Alliances influence votes and duel picks.</div></div>
  </section>

  <section class="card">
    <h2>Progress</h2>
    <div class="content">
      <table class="vm">
        <thead><tr><th>Player</th><th>P1</th><th>P2</th><th>P3</th></tr></thead>
        <tbody id="progressBody"></tbody>
      </table>
    </div>
  </section>

  <section class="card">
    <h2>Jury Key Matrix</h2>
    <div class="content">
      <div class="muted">Appears in Finale. Budgets: P1 juror=1, P2 juror=2, P3 juror=3. Total = 27 keys.</div>
      <div id="juryMatrixWrap"></div>
    </div>
  </section>
</main>

<!-- Image support: normalize any Imgur link and render safely -->
<script>
function toDirectImgur(url){
  if(!url) return '';
  let m=url.match(/^https?:\/\/i\.imgur\.com\/([A-Za-z0-9]+)\.(?:jpg|jpeg|png|gif|webp|avif|gifv)$/i);
  if(m) return `https://i.imgur.com/${m[1]}.jpg`;
  m=url.match(/^https?:\/\/imgur\.com\/(?:gallery|a)\/[A-Za-z0-9]+#([A-Za-z0-9]+)/i);
  if(m) return `https://i.imgur.com/${m[1]}.jpg`;
  m=url.match(/^https?:\/\/imgur\.com\/([A-Za-z0-9]+)(?:[#?].*)?$/i);
  if(m) return `https://i.imgur.com/${m[1]}.jpg`;
  m=url.match(/^https?:\/\/i\.imgur\.com\/([A-Za-z0-9]+)\.[A-Za-z0-9]+/i);
  if(m) return `https://i.imgur.com/${m[1]}.jpg`;
  return url;
}
const __FALLBACK_PX__='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8Xw8AAqMBw3e4gqEAAAAASUVORK5CYII=';
function setImageSrc(img,raw){
  const u=toDirectImgur(raw);
  img.setAttribute('referrerpolicy','no-referrer');
  img.alt=img.alt||'Image';
  img.src=u||__FALLBACK_PX__;
  let tried=false;
  img.onerror=()=>{ if(!tried && /\.jpg$/i.test(img.src)){ tried=true; img.src=img.src.replace(/\.jpg$/i,'.png'); } else img.src=__FALLBACK_PX__; };
}
const __obs=new MutationObserver(ms=>{
  for(const m of ms){
    m.addedNodes.forEach(n=>{
      if(n.nodeType!==1) return;
      if(n.tagName==='IMG'){ const raw=n.getAttribute('src')||n.getAttribute('data-src')||''; if(raw) setImageSrc(n,raw); }
      n.querySelectorAll&&n.querySelectorAll('img').forEach(im=>{const r=im.getAttribute('src')||im.getAttribute('data-src')||''; if(r) setImageSrc(im,r);});
    });
  }
});
__obs.observe(document.documentElement,{childList:true,subtree:true});
function logEventWithImages(text,urls){
  const feed=document.getElementById('events');
  const box=document.createElement('div'); box.className='event';
  const p=document.createElement('div'); p.className='evt-text'; p.textContent=text; box.appendChild(p);
  if(Array.isArray(urls)&&urls.length){
    const strip=document.createElement('div'); strip.className='evt-images';
    urls.forEach(u=>{ const im=document.createElement('img'); im.setAttribute('data-src',u); strip.appendChild(im); });
    box.appendChild(strip);
  }
  feed.appendChild(box);
}
</script>

<script>
/* =========================
   ALT VAULT GAME ENGINE
   ========================= */

const UI = {
  playersInput: document.getElementById('playersInput'),
  photosInput:  document.getElementById('photosInput'),
  startBtn:     document.getElementById('startBtn'),
  resetBtn:     document.getElementById('resetBtn'),
  nextBtn:      document.getElementById('nextBtn'),
  againBtn:     document.getElementById('againBtn'),
  phaseLabel:   document.getElementById('phaseLabel'),
  events:       document.getElementById('events'),
  vmWrap:       document.getElementById('voteMatrixWrap'),
  alliancesBox: document.getElementById('alliancesBox'),
  progressBody: document.getElementById('progressBody'),
  juryWrap:     document.getElementById('juryMatrixWrap'),
};

const S = {
  phase: 0, round: 0,
  roster: [],             // [{name,img,p1:false,p2:false,p3:false,alive:true}]
  alliances: [],
  p1Jurors: [], p2Jurors: [], p3Jurors: [],
  finalists: [],
};

function resetAll(){
  S.phase=0; S.round=0; S.roster=[]; S.alliances=[]; S.p1Jurors=[]; S.p2Jurors=[]; S.p3Jurors=[]; S.finalists=[];
  UI.events.innerHTML=''; UI.vmWrap.innerHTML=''; UI.juryWrap.innerHTML='';
  UI.progressBody.innerHTML=''; UI.phaseLabel.textContent='';
  UI.nextBtn.classList.add('hidden'); UI.againBtn.classList.add('hidden');
  UI.alliancesBox.innerHTML='<div class="muted">Generated at start. Alliances influence votes and duel picks.</div>';
}

function startGame(){
  const names=UI.playersInput.value.split('\n').map(s=>s.trim()).filter(Boolean);
  if(names.length!==13){ alert('Enter exactly 13 players.'); return; }
  const photos=UI.photosInput.value.split('\n').map(s=>s.trim());
  S.roster=names.map((n,i)=>({name:n,img:photos[i]||'',p1:false,p2:false,p3:false,alive:true}));
  genAlliances();
  renderProgress();
  S.phase=1; S.round=1; UI.phaseLabel.textContent='Phase 1 — Round 1 of 5';
  logEventWithImages('Phase 1 begins. Rounds 1–4: draw 6, house votes, then challenge. Round 5 is the Last Chance Vote.',[]);
  UI.nextBtn.classList.remove('hidden'); UI.againBtn.classList.add('hidden');
}

function simulateAgain(){
  const names=S.roster.map(p=>p.name); const imgs=S.roster.map(p=>p.img);
  UI.playersInput.value=names.join('\n'); UI.photosInput.value=imgs.join('\n');
  resetAll(); startGame();
}

/* ---------- Alliances ---------- */
function genAlliances(){
  const names=S.roster.map(p=>p.name);
  // Make 3 alliances of 5 each, overlapping allowed
  const A=[];
  for(let i=1;i<=3;i++){
    const shuf=[...names].sort(()=>Math.random()-0.5);
    const size=5;
    A.push({name:`Alliance ${i}`, members:new Set(shuf.slice(0,size))});
  }
  S.alliances=A; renderAlliances();
}
function renderAlliances(){
  UI.alliancesBox.innerHTML='';
  S.alliances.forEach(a=>{
    const box=document.createElement('div');
    box.innerHTML=`<div><strong>${a.name}</strong></div>`;
    const wrap=document.createElement('div');
    a.members.forEach(n=>{ const s=document.createElement('span'); s.className='pill'; s.textContent=n; wrap.appendChild(s); });
    box.appendChild(wrap); UI.alliancesBox.appendChild(box);
  });
}

/* ---------- Helpers ---------- */
function alive(){ return S.roster.filter(p=>p.alive); }
function withoutP1(){ return alive().filter(p=>!p.p1); }
function withP1(){ return alive().filter(p=>p.p1); }
function withoutP2(){ return alive().filter(p=>!p.p2); }
function withP2(){ return alive().filter(p=>p.p2); }
function byName(n){ return S.roster.find(p=>p.name===n); }
function choice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }
function voteAmong(voters, targets, forbidSelf=true, biasAllies=true, favorOutside=false){
  // returns map { voterName: targetName }
  const map={};
  voters.forEach(v=>{
    const a=S.alliances.find(x=>x.members.has(v.name));
    let opts=targets.map(t=>t.name);
    if(forbidSelf) opts=opts.filter(n=>n!==v.name);
    if(biasAllies && a){
      if(favorOutside){ // prefer outside alliance
        const outside=opts.filter(n=>!a.members.has(n));
        if(outside.length) opts=outside;
      } else { // prefer allies
        const inside=opts.filter(n=>a.members.has(n));
        if(inside.length) opts=inside;
      }
    }
    map[v.name]=opts.length?choice(opts):choice(targets).name;
  });
  return map;
}
function tally(map){
  const t={}; Object.values(map).forEach(n=>t[n]=(t[n]||0)+1); return t;
}
function topAndTies(t){
  const vals=Object.values(t); const max=Math.max(...vals);
  const tied=Object.keys(t).filter(n=>t[n]===max);
  return {max, tied};
}
function renderVoteMatrix(voters, map){
  const table=document.createElement('table'); table.className='vm';
  const thead=document.createElement('thead'); const hr=document.createElement('tr');
  ['Voter','Voted For'].forEach(h=>{const th=document.createElement('th'); th.textContent=h; hr.appendChild(th);});
  thead.appendChild(hr); table.appendChild(thead);
  const tb=document.createElement('tbody');
  voters.forEach(v=>{
    const tr=document.createElement('tr');
    const tdV=document.createElement('td'); const im=document.createElement('img'); im.className='avatar'; setImageSrc(im,v.img||''); tdV.appendChild(im); tdV.appendChild(document.createTextNode(' '+v.name));
    const tdT=document.createElement('td'); tdT.textContent=map[v.name]||'—';
    tr.appendChild(tdV); tr.appendChild(tdT); tb.appendChild(tr);
  });
  table.appendChild(tb);
  UI.vmWrap.innerHTML=''; UI.vmWrap.appendChild(table);
}
function renderProgress(){
  UI.progressBody.innerHTML='';
  S.roster.forEach(p=>{
    const tr=document.createElement('tr');
    tr.innerHTML=`<td>${p.name}</td><td>${p.p1?'✓':''}</td><td>${p.p2?'✓':''}</td><td>${p.p3?'✓':''}</td>`;
    UI.progressBody.appendChild(tr);
  });
}

/* ======================
   PHASE 1 — 5 ROUNDS
   ====================== */
function phase1Next(){
  if(S.round<=4){
    // Rounds 1–4
    UI.vmWrap.innerHTML='';
    const drawn = (S.round===4) ? withoutP1() : shuffle(withoutP1()).slice(0,6);
    const drawnNames = drawn.map(p=>p.name);
    const label = (S.round===4) ? `Round ${S.round}: Round 4 exception — all without a P1 key are drawn.` : `Round ${S.round}: Drawn for vote and challenge: ${drawnNames.join(', ')}`;
    logEventWithImages(label, drawn.map(p=>p.img||''));

    // Vote among all 13 alive (Phase 1 keeps all 13 alive)
    const voters = alive();
    // primary vote
    let map = voteAmong(voters, drawn, true, false, false);
    renderVoteMatrix(voters, map);
    let t = tally(map); let {tied} = topAndTies(t);

    if(tied.length===1){
      // clear winner
      const win = byName(tied[0]);
      if(!win.p1){ win.p1=true; }
      logEventWithImages(`${win.name} wins the vote and receives the Phase 1 vote key.`, [win.img||'']);
      // Challenge among remaining drawn who don't yet have P1
      const remain = drawn.filter(p=>p.name!==win.name && !p.p1);
      const pool = remain.length?remain:drawn.filter(p=>p.name!==win.name); // fallback
      const cw = choice(pool);
      if(!cw.p1){ cw.p1=true; }
      logEventWithImages(`${cw.name} wins the challenge key.`, [cw.img||'']);

    } else {
      // TIE → REVOTE among tied
      logEventWithImages(`Tie for top votes among: ${tied.join(', ')}. Automatic revote between tied players.`, tied.map(n=>byName(n).img||''));
      const tiedObjs = tied.map(byName);
      const map2 = voteAmong(voters, tiedObjs, true, false, false);
      renderVoteMatrix(voters, map2);
      const t2 = tally(map2); const {tied: tied2} = topAndTies(t2);

      if(tied2.length===1){
        const win = byName(tied2[0]);
        if(!win.p1){ win.p1=true; }
        logEventWithImages(`${win.name} wins the revote and receives the Phase 1 vote key.`, [win.img||'']);
        // Challenge among remaining drawn without P1
        const remain = drawn.filter(p=>p.name!==win.name && !p.p1);
        const pool = remain.length?remain:drawn.filter(p=>p.name!==win.name);
        const cw = choice(pool);
        if(!cw.p1){ cw.p1=true; }
        logEventWithImages(`${cw.name} wins the challenge key.`, [cw.img||'']);
      } else {
        // Revote also ties → all drawn compete; challenge winner gets challenge key AND must give vote key to someone from tied group
        logEventWithImages(`Revote ties again. All drawn compete in the challenge. Winner will also award the vote key to one of the tied players.`, drawn.map(p=>p.img||''));
        const cw = choice(drawn);
        if(!cw.p1){ cw.p1=true; }
        logEventWithImages(`${cw.name} wins the challenge key.`, [cw.img||'']);

        // Challenge winner chooses among tied to give the vote key
        const tiedPrefer = tied2.map(byName).filter(p=>!p.p1); // prefer tied without P1
        const pick = tiedPrefer.length ? choice(tiedPrefer) : byName(choice(tied2));
        if(!pick.p1){ pick.p1=true; }
        logEventWithImages(`${cw.name} awards the vote key to ${pick.name} from the tied group.`, [cw.img||'', pick.img||'']);
      }
    }

    renderProgress();
    S.round++;
    UI.phaseLabel.textContent = `Phase 1 — Round ${Math.min(S.round,5)} of 5`;
    if(S.round===5){
      // Last Chance Vote next
      logEventWithImages(`Round 5 — Last Chance Vote: only players without P1 keys vote for one of their own to get a key. Others will be eliminated.`,[]);
    }
  } else if (S.round===5){
    // Last Chance Vote
    UI.vmWrap.innerHTML='';
    const noKey = withoutP1();
    // Expect exactly 5; handle edge cases gracefully.
    if(noKey.length===0){
      logEventWithImages(`No players without a P1 key. Skipping Last Chance Vote.`,[]);
    } else {
      const voters=noKey; const targets=noKey;
      const map=voteAmong(voters, targets, true, false, false);
      renderVoteMatrix(voters, map);
      const t=tally(map); const {tied}=topAndTies(t);
      const winner = byName(choice(tied)); // break any tie randomly among the top
      if(!winner.p1){ winner.p1=true; }
      logEventWithImages(`${winner.name} receives the Last Chance vote key.`, [winner.img||'']);
      // Everyone else without key is eliminated → P1 jury
      const elim = withoutP1(); // recompute; these are now zero‑key after the award
      elim.forEach(p=>{ p.alive=false; S.p1Jurors.push(p.name); });
      if(elim.length) logEventWithImages(`Phase 1 eliminations: ${elim.map(p=>p.name).join(', ')}`, elim.map(p=>p.img||''));
    }
    renderProgress();
    // Move to Phase 2 with exactly 9 alive
    const aliveNow=alive();
    if(aliveNow.length!==9){
      // If more than 9 for any edge case, prune extras by fewest votes heuristic (random here)
      while(alive().length>9){ const p=choice(alive()); p.alive=false; S.p1Jurors.push(p.name); }
      // If fewer than 9 (shouldn’t happen), revive random until 9
      while(alive().length<9){ const dead=S.roster.filter(p=>!p.alive); const p=choice(dead); p.alive=true; const idx=S.p1Jurors.indexOf(p.name); if(idx>-1) S.p1Jurors.splice(idx,1); }
    }
    S.phase=2; S.round=1; UI.phaseLabel.textContent='Phase 2 — Round 1 of 5';
    logEventWithImages(`Phase 2 begins. Goal: earn a second key. Rounds 1–4 are vote→duel; Round 5 is Last Chance Challenge.`,[]);
  } else {
    // Should not reach here
  }
}

/* ======================
   PHASE 2 — 5 ROUNDS
   ====================== */
function phase2Next(){
  if(S.round<=4){
    UI.vmWrap.innerHTML='';
    const players=alive(); // 9
    // Vote for someone without a Phase 2 key
    const elig=players.filter(p=>!p.p2);
    const voters=players;
    const map=voteAmong(voters, elig, true, true, true); // favor outside alliance to set up easy duels
    renderVoteMatrix(voters, map);
    const t=tally(map); const {tied}=topAndTies(t);

    let voteWinner;
    if(tied.length===1){
      voteWinner=byName(tied[0]);
      logEventWithImages(`House selects ${voteWinner.name} to set the duel.`, [voteWinner.img||'']);
    } else if (tied.length===2){
      // Two-way tie → revote between tied players only
      const tiedObjs=tied.map(byName);
      logEventWithImages(`Two-way tie between ${tied.join(' & ')}. Revote between tied players only.`, tiedObjs.map(p=>p.img||''));
      const map2=voteAmong(voters, tiedObjs, true, false, false);
      renderVoteMatrix(voters, map2);
      const t2=tally(map2); const {tied:tt}=topAndTies(t2);
      voteWinner=byName(choice(tt));
      logEventWithImages(`${voteWinner.name} wins the revote to set the duel.`, [voteWinner.img||'']);
    } else if (tied.length===3){
      // Three-way tie → triple duel among the three tied
      const trio=tied.map(byName);
      logEventWithImages(`Three-way tie among ${tied.join(', ')}. Triple duel!`, trio.map(p=>p.img||''));
      const duelWinner=choice(trio);
      if(!duelWinner.p2){ duelWinner.p2=true; }
      logEventWithImages(`${duelWinner.name} wins the triple duel and the Phase 2 key.`, [duelWinner.img||'']);
      renderProgress();
      S.round++; UI.phaseLabel.textContent=`Phase 2 — Round ${Math.min(S.round,5)} of 5`;
      if(S.round===5) logEventWithImages(`Round 5 — Last Chance Challenge: the 5 without P2 keys compete for the final key.`,[]);
      return;
    } else if (tied.length>=4){
      // Four-way tie (or more): player who did not vote for any of the tied breaks it.
      const tiedSet=new Set(tied);
      const breakers=voters.filter(v=>!tiedSet.has(map[v.name]));
      if(breakers.length){
        const breaker=choice(breakers);
        const pick=choice(tied);
        voteWinner=byName(pick);
        logEventWithImages(`Multi-way tie. ${breaker.name} did not vote for any tied player and breaks the tie → ${voteWinner.name} sets the duel.`, [breaker.img||'', voteWinner.img||'']);
      } else {
        voteWinner=byName(choice(tied));
        logEventWithImages(`Multi-way tie with no clear breaker. Randomly choosing ${voteWinner.name} to set the duel.`, [voteWinner.img||'']);
      }
    }

    // Vote winner chooses 1 opponent without a P2 key
    const options=elig.filter(p=>p.name!==voteWinner.name);
    const ally=S.alliances.find(a=>a.members.has(voteWinner.name));
    let opponent;
    if(ally){
      const outside=options.filter(p=>!ally.members.has(p.name));
      opponent = outside.length? choice(outside): choice(options);
    } else opponent=choice(options);
    logEventWithImages(`${voteWinner.name} chooses to duel ${opponent.name}.`, [voteWinner.img||'', opponent.img||'']);

    // Duel
    const winner=Math.random()<0.5?voteWinner:opponent;
    if(!winner.p2){ winner.p2=true; }
    logEventWithImages(`${winner.name} wins the duel and the Phase 2 key.`, [winner.img||'']);
    renderProgress();

    S.round++; UI.phaseLabel.textContent=`Phase 2 — Round ${Math.min(S.round,5)} of 5`;
    if(S.round===5) logEventWithImages(`Round 5 — Last Chance Challenge: the 5 without P2 keys compete for the final key.`,[]);
  } else if (S.round===5){
    // Last Chance Challenge among 5 without P2 keys
    const noP2=withoutP2();
    if(noP2.length===0){
      logEventWithImages(`All players already have a P2 key. Skipping Last Chance Challenge.`,[]);
    } else {
      // Expect exactly 5; if more, limit to 5 by random; if fewer, let all compete.
      const pool = noP2.length>5 ? shuffle(noP2).slice(0,5) : noP2;
      logEventWithImages(`Last Chance Challenge among: ${pool.map(p=>p.name).join(', ')}`, pool.map(p=>p.img||''));
      const w=choice(pool);
      if(!w.p2){ w.p2=true; }
      logEventWithImages(`${w.name} wins the last Phase 2 key.`, [w.img||'']);

      // Others in pool without P2 and any remaining without P2 are eliminated → P2 jury
      const losers = withoutP2();
      losers.forEach(p=>{ p.alive=false; S.p2Jurors.push(p.name); });
      if(losers.length) logEventWithImages(`Phase 2 eliminations: ${losers.map(p=>p.name).join(', ')}`, losers.map(p=>p.img||''));
    }
    renderProgress();
    // Proceed to Phase 3 with 5 remaining
    // Ensure exactly 5 alive
    while(alive().length>5){ const p=choice(alive()); p.alive=false; S.p2Jurors.push(p.name); }
    while(alive().length<5){ const dead=S.roster.filter(p=>!p.alive && p.p1); const p=choice(dead); if(p){ p.alive=true; const i=S.p2Jurors.indexOf(p.name); if(i>-1) S.p2Jurors.splice(i,1);} else break; }
    S.phase=3; S.round=1; UI.phaseLabel.textContent='Phase 3 — Final Cut';
    logEventWithImages(`Phase 3 begins. House vote selects a Vote Winner who advances and brings one. The remaining three duel in a challenge for the last spot.`,[]);
  }
}

/* ======================
   PHASE 3 — FINAL CUT
   ====================== */
function phase3Run(){
  UI.vmWrap.innerHTML='';
  const five=alive(); // 5
  // House vote (no self vote)
  const map=voteAmong(five, five, true, true, false);
  renderVoteMatrix(five, map);
  const t=tally(map); const {tied}=topAndTies(t);
  let voteWinner;
  if(tied.length===1){
    voteWinner=byName(tied[0]);
  } else {
    // Break ties randomly for vote winner
    voteWinner=byName(choice(tied));
  }
  voteWinner.p3=true; // advances, counts as third key
  // vote winner chooses one to join
  const others=five.filter(p=>p.name!==voteWinner.name);
  const ally=S.alliances.find(a=>a.members.has(voteWinner.name));
  let pick;
  if(ally){
    const prefer=others.filter(p=>ally.members.has(p.name));
    pick=prefer.length?choice(prefer):choice(others);
  } else pick=choice(others);
  pick.p3=true;

  // Remaining three challenge for last spot
  const rest=others.filter(p=>p.name!==pick.name);
  logEventWithImages(`${voteWinner.name} wins the vote and advances, choosing ${pick.name}. The remaining three compete for the last spot.`, [voteWinner.img||'', pick.img||'']);
  const duelWinner=choice(rest);
  duelWinner.p3=true;
  const losers=rest.filter(p=>p.name!==duelWinner.name);
  losers.forEach(p=>{ p.alive=false; S.p3Jurors.push(p.name); });
  logEventWithImages(`${duelWinner.name} wins the final challenge and reaches the finale. Eliminated: ${losers.map(p=>p.name).join(' & ')}.`, [duelWinner.img||''].concat(losers.map(p=>p.img||'')));
  renderProgress();

  S.finalists=[voteWinner,pick,duelWinner];
  S.phase=4; UI.phaseLabel.textContent='Finale — The Vault';
  runFinale();
}

/* ======================
   FINALE — VAULT
   ====================== */
function runFinale(){
  // 3 finalists each with 3 keys already from phases 1–3
  const F=S.finalists;

  // Build jurors
  const p1=S.p1Jurors.map(byName);
  const p2=S.p2Jurors.map(byName);
  const p3=S.p3Jurors.map(byName);

  // Budgets: P1=1 each, P2=2 each, P3=3 each
  const budgets=new Map();
  p1.forEach(j=>budgets.set(j.name,(budgets.get(j.name)||0)+1));
  p2.forEach(j=>budgets.set(j.name,(budgets.get(j.name)||0)+2));
  p3.forEach(j=>budgets.set(j.name,(budgets.get(j.name)||0)+3));

  // Scale to exactly 27 keys total if natural total differs
  let natural=0; budgets.forEach(v=>natural+=v);
  const target=27;
  const jurors=[...budgets.keys()];
  const scaled=new Map();
  if(natural===target){
    budgets.forEach((v,k)=>scaled.set(k,v));
  } else if(natural>0){
    let acc=0;
    jurors.forEach((k,i)=>{
      let v=Math.round(budgets.get(k)*target/natural);
      if(i===jurors.length-1) v=Math.max(0,target-acc);
      scaled.set(k,v); acc+=v;
    });
  }

  // Distribute: each juror can split however they choose. Randomly allocate each key to a finalist.
  const dist=new Map(F.map(x=>[x.name,0]));
  jurors.forEach(j=>{
    let b=scaled.get(j);
    while(b>0){ const f=choice(F); dist.set(f.name, dist.get(f.name)+1); b--; }
  });

  // Render jury matrix
  renderJuryMatrix(jurors, scaled, F, dist);

  // Vault selection: 3–22 unique. Pick values based on conservative expectations.
  const vaults=[3,4,5,6,7,8,9,10,11,12,14,16,18,20,22];
  const taken=new Set(); const pickMap=new Map();
  F.forEach(f=>{
    // estimate: 6–10 total keys typically; pick highest not exceeding est
    const expect = 6 + Math.floor(Math.random()*5); // 6–10
    let pick = 3;
    for(const v of vaults){ if(!taken.has(v) && v<=expect) pick=v; }
    if(taken.has(pick)) pick = vaults.find(v=>!taken.has(v))||3;
    taken.add(pick); pickMap.set(f.name,pick);
  });

  // Reveal and decide winner
  const results=[];
  F.forEach(f=>{
    const base=3; // already have P1,P2,P3
    const jury=dist.get(f.name);
    const total=base + jury;
    const need=pickMap.get(f.name);
    const opens= total>=need;
    results.push({name:f.name,total,need,opens});
    logEventWithImages(`${f.name} stands at a ${need}-key vault with ${total} keys. ${opens?'It opens.':'It does not open.'}`, [f.img||'']);
  });

  const openers=results.filter(r=>r.opens).sort((a,b)=>b.need-a.need);
  let winner;
  if(openers.length){
    winner=openers[0].name;
    logEventWithImages(`Winner: ${winner} — opened the highest vault among finalists.`, [byName(winner).img||'']);
  } else {
    // Final challenge among the three; winner gets the 3-key vault and wins.
    const champ=choice(F);
    logEventWithImages(`No vault opens. Final three compete in a last challenge. ${champ.name} wins and claims the 3‑key vault.`, [champ.img||'']);
    winner=champ.name;
  }

  UI.nextBtn.classList.add('hidden'); UI.againBtn.classList.remove('hidden');
}

/* ---------- Jury Matrix Render ---------- */
function renderJuryMatrix(jurorNames, budgets, finalists, dist){
  UI.juryWrap.innerHTML='';
  const table=document.createElement('table'); table.className='vm';
  const thead=document.createElement('thead'); const hr=document.createElement('tr');
  ['Juror','Budget','Allocation'].forEach(h=>{const th=document.createElement('th'); th.textContent=h; hr.appendChild(th);});
  thead.appendChild(hr); table.appendChild(thead);
  const tb=document.createElement('tbody');
  jurorNames.forEach(n=>{
    const tr=document.createElement('tr');
    const tdJ=document.createElement('td'); tdJ.textContent=n;
    const tdB=document.createElement('td'); tdB.textContent=budgets.get(n);
    // For transparency, we display "random split" since allocations are per-key random
    const tdA=document.createElement('td'); tdA.textContent='random split';
    tr.appendChild(tdJ); tr.appendChild(tdB); tr.appendChild(tdA); tb.appendChild(tr);
  });
  table.appendChild(tb);
  const totals=document.createElement('div');
  const sum=[...dist.entries()].map(([k,v])=>`${k}: ${v}`).join(' | ');
  totals.className='muted';
  totals.textContent=`Finalist jury totals (must equal 27): ${sum}`;
  UI.juryWrap.appendChild(table); UI.juryWrap.appendChild(totals);
}

/* ---------- Button wiring ---------- */
UI.startBtn.addEventListener('click', ()=>{ resetAll(); startGame(); });
UI.resetBtn.addEventListener('click', resetAll);
UI.nextBtn.addEventListener('click', ()=>{
  if(S.phase===1) return phase1Next();
  if(S.phase===2) return phase2Next();
  if(S.phase===3) return phase3Run();
});
UI.againBtn.addEventListener('click', simulateAgain);
</script>
</body>
</html>