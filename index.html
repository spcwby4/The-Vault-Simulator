<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Vault Simulator — Episodes + Events</title>
<style>
  :root{
    --bg:#0f1115; --panel:#161a22; --panel2:#1c2130; --muted:#2a2f3a; --text:#e5e7eb; --sub:#aeb4c0;
    --accent:#7aa2ff; --good:#6ee7b7; --warn:#fbbf24; --bad:#f87171; --border:#2b3340;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  h1{margin:0;font-size:20px}
  h2{margin:0 0 10px;font-size:16px}
  textarea,button,input,select{width:100%;padding:12px;margin-top:8px;border-radius:10px;border:1px solid var(--border);background:var(--panel);color:var(--text);font-size:16px}
  button{cursor:pointer} button:hover{background:var(--panel2)}
  .app{display:grid;grid-template-columns:280px 1fr;min-height:100vh}
  .sidebar{background:var(--panel);border-right:1px solid var(--border);padding:14px 12px;display:flex;flex-direction:column;gap:12px;position:sticky;top:0;height:100vh}
  .brand{display:flex;align-items:center;justify-content:space-between;gap:10px}
  .hamburger{display:none;font-size:18px;padding:8px 10px;border-radius:8px;background:var(--panel2)}
  .epList{flex:1;overflow:auto;border:1px solid var(--border);border-radius:10px}
  .epItem{padding:10px;border-bottom:1px solid var(--border);display:flex;gap:10px;align-items:center}
  .epItem:last-child{border-bottom:none}
  .thumb{width:36px;height:36px;border-radius:8px;background:var(--muted);display:flex;align-items:center;justify-content:center;font-size:12px}
  .main{padding:18px;display:grid;gap:16px}
  .box{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:14px}
  .row{display:flex;gap:14px;flex-wrap:wrap}
  .col{flex:1 1 280px}
  pre{white-space:pre-wrap;background:var(--bg);border:1px solid var(--border);border-radius:10px;padding:10px;min-height:200px;max-height:260px;overflow:auto}
  table{width:100%;border-collapse:collapse}
  th,td{border:1px solid var(--border);padding:8px;text-align:center;white-space:nowrap}
  th{background:var(--panel2)}
  .btnrow{display:flex;gap:10px;flex-wrap:wrap}
  .chip{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--border);padding:6px 8px;border-radius:8px}
  .avatar{width:22px;height:22px;border-radius:6px;object-fit:cover;background:var(--muted);display:inline-flex;align-items:center;justify-content:center;font-size:11px}
  .hint{font-size:13px;color:var(--sub)}
  .toggle{display:flex;align-items:center;gap:8px;font-size:13px;color:var(--sub)}
  .toggle span{color:var(--text);font-weight:600;line-height:1.2}

  @media (max-width: 900px){
    .app{grid-template-columns:1fr}
    .sidebar{position:relative;height:auto}
    .hamburger{display:inline-block}
    .sidebar.collapsed .collapsible-area{display:none}
    .main{padding:12px}
    textarea,button,input,select{font-size:16px}
    pre{min-height:180px}
  }
</style>
</head>
<body>
<div class="app">
  <!-- Sidebar -->
  <aside class="sidebar collapsed" id="sidebar">
    <div class="brand">
      <h1>Vault Episodes</h1>
      <button class="hamburger" id="hamburger">☰</button>
    </div>
    <div class="collapsible-area">
      <label class="toggle"><input type="checkbox" id="spoilerToggle"/><span>Spoiler‑free nav</span></label>

      <!-- Season Controls -->
      <div class="box" id="seasonControls">
        <h2>Season Controls</h2>
        <label>Alliance Preset</label>
        <select id="alliancePreset">
          <option value="fluid">Fluid webs (default)</option>
          <option value="loyal">Loyal blocs</option>
          <option value="duos">Duo‑centric</option>
          <option value="loners">Loners thrive</option>
        </select>
        <hr style="border-color:var(--border);margin:12px 0">
        <h3 style="margin:0 0 6px;font-size:15px">Twists (season‑wide)</h3>
        <label class="toggle"><input type="checkbox" id="tw_noLockpick"><span>No Lockpick this season</span></label>
        <label class="toggle"><input type="checkbox" id="tw_doubleDuel"><span>Double Duel (picker names TWO → single 3‑way duel)</span></label>
        <div class="hint">These lock and disappear after you press <em>Start Season</em>.</div>
      </div>

      <div class="epList" id="epList"></div>
    </div>
  </aside>

  <!-- Main -->
  <main class="main">
    <div class="box">
      <div class="row">
        <div class="col">
          <label><strong>Enter 12 Players (one per line)</strong></label>
          <textarea id="playerInput" rows="12" placeholder="Player 1&#10;Player 2&#10;..."></textarea>
          <div class="btnrow" style="margin-top:6px">
            <button id="startBtn">Start Season</button>
            <button id="nextBtn" style="display:none;">Next Scene ▶</button>
          </div>
          <div class="hint">Each episode = exactly one round. Episode 1 is Phase 1, Round 1.</div>
        </div>
        <div class="col" id="castBox">
          <h2>Cast Photos & Colors</h2>
          <div id="castGrid"></div>
        </div>
      </div>
    </div>

    <div class="box" id="preseasonBox">
      <h2>Preseason: Stats & Relationships</h2>
      <div class="row">
        <div class="col">
          <h3 style="margin:0 0 6px">Player Stats</h3>
          <div id="statsTable"></div>
          <div class="btnrow" style="margin-top:6px">
            <button id="presetBalanced">Balanced</button>
            <button id="presetSocial">Social‑heavy</button>
            <button id="presetChallenge">Challenge‑heavy</button>
            <button id="presetRandom">Randomize All</button>
            <button id="applyStats">Apply Stats</button>
          </div>
          <div class="hint">Range: 1–15 (default 8/8). Hidden during play.</div>
        </div>
        <div class="col">
          <h3 style="margin:0 0 6px">Relationships (−5…+5)</h3>
          <div class="row" style="align-items:center">
            <label>Focus</label>
            <select id="relFocus"></select>
          </div>
          <div id="relEditor" style="margin-top:6px"></div>
          <div class="btnrow" style="margin-top:6px">
            <button id="relSave">Save (All)</button>
            <button id="relRandFocus">Randomize Focus</button>
            <button id="relClearFocus">Clear Focus</button>
            <button id="relRandAll">Randomize All</button>
            <button id="relClearAll">Clear All</button>
          </div>
        </div>
      </div>
    </div>

    <div class="box">
      <h2>Round Events (Scene feed)</h2>
      <pre id="sceneFeed">(Ready) Tap “Next Scene”.</pre>
    </div>

    <div class="row">
      <div class="box col">
        <h2>Alliances</h2>
        <div id="alliancesList"></div>
      </div>
      <div class="box col">
        <h2>Progress</h2>
        <div id="progressChart"></div>
      </div>
    </div>

    <div class="row">
      <div class="box col">
        <h2>Voting Matrix (Season)</h2>
        <div id="votingMatrix"></div>
        <div class="hint">LOCKPICK appears if used. Order: active → P3 elim → P2 elim → P1 elim.</div>
      </div>
      <div class="box col">
        <h2>Relationships (Live)</h2>
        <div id="relsLive"></div>
      </div>
    </div>

    <div class="box">
      <h2>Jury Key Distribution</h2>
      <div id="juryMatrix"></div>
    </div>
  </main>
</div>

<script>
/* ===== Season Options ===== */
var SEASON = { preset:'fluid', noLockpick:false, doubleDuel:false };

/* ===== Tunables ===== */
var ALPHA_SOCIAL=0.65, BETA_CHALLENGE=1.0, GAMMA_BEATABLE=1.2;
var LOGIT_K=0.7, WIN_CLAMP_LO=0.15, WIN_CLAMP_HI=0.85;
var VOTE_JITTER_MIN=0.8, VOTE_JITTER_MAX=1.2, ALLY_PREFERENCE_RATE=0.6;
var REL_SCALE=0.08, REL_MIN_FACTOR=0.3;

/* ===== Event Library (BrantSteele‑style) ===== */
const EVENT_LIBRARY = [
  {type:'bond',    text:(a,b)=>`${a} flips ${b}'s mattress back after a prank; they laugh it off. (+1)`, w:2},
  {type:'tension', text:(a,b)=>`${a} flips ${b}'s mattress during a nap. (-1)`, w:1},
  {type:'tension', text:(a,b)=>`${a} accidentally breaks ${b}'s mug. Tension rises. (-1)`, w:1},
  {type:'bond',    text:(a,b)=>`${a} replaces ${b}'s broken mug with a new one. (+1)`, w:1},
  {type:'tension', text:(a,b)=>`A plane flies overhead with a banner: “${b} is not to be trusted!” ${a} side‑eyes ${b}. (-1)`, w:1},
  {type:'bond',    text:(a,b)=>`${a} comforts ${b} after a rough day. (+1)`, w:2},
  {type:'tension', text:(a,b)=>`${a} spreads a rumor that ${b} has the Lockpick. (-1)`, w:1},
  {type:'bond',    text:(a,b)=>`${a} shares food with ${b}. (+1)`, w:2},
  {type:'tension', text:(a,b)=>`${a} hogs the shower and ${b} calls them out. (-1)`, w:1},
  {type:'bond',    text:(a,b)=>`${a} and ${b} stay up strategizing together. (+1)`, w:2},
  {type:'tension', text:(a,b)=>`${a} “accidentally” hides ${b}'s shoes before the draw. (-1)`, w:1},
  {type:'bond',    text:(a,b)=>`${a} teaches ${b} a challenge trick. (+1)`, w:2},
  {type:'tension', text:(a,b)=>`${a} refuses to throw a duel for ${b}. (-1)`, w:1}
];

/* ===== State ===== */
var players=[], initialOrder=[], phase=1, round=1;
var alliances={}, keys={}, jury=[], finalists=[], eliminated=[];
var lockpickHolder=null, lockpickUsed=false, lockpickFound=false;
var voteColumns=[], knownVoters=[], vaults=[]; for(var i=3;i<=22;i++) vaults.push(i);
var gameStarted=false;

/* Episodes / scenes */
var episodes=[], currentEpisode=null, sceneQueue=[], sceneIndex=0, spoilerFree=false;

/* Stats / rel / cast */
var stats={}, rel={}, cast={};
var wins={}, losses={}, keysEarned={}, votesGiven={}, votesReceived={}, juryKeysReceived={};

/* Step temps */
var p1_step=0, p2_step=0, p3_step=0;
var p1_drawn=[], p1_votePairs=[], p1_winner=null, p1_lockUser=null, p1_chalWin=null;
var p2_noKey=[], p2_votePairs=[], p2_winner=null, p2_lockUser=null, p2_picks=[], p2_reasonText='';
var p3_voteWinner=null, p3_chosenAlly=null, p3_duelists=[];

/* ===== DOM ===== */
var sidebar=document.getElementById('sidebar');
document.getElementById('hamburger').onclick=function(){ sidebar.classList.toggle('collapsed'); };
var startBtn=document.getElementById('startBtn'), nextBtn=document.getElementById('nextBtn');
var sceneFeed=document.getElementById('sceneFeed'), epListDiv=document.getElementById('epList');
document.getElementById('spoilerToggle').onchange=function(){ spoilerFree=this.checked; renderEpisodeNav(); };
document.getElementById('alliancePreset').onchange=function(){ SEASON.preset=this.value; };
document.getElementById('tw_noLockpick').onchange=function(){ SEASON.noLockpick=this.checked; };
document.getElementById('tw_doubleDuel').onchange=function(){ SEASON.doubleDuel=this.checked; };
startBtn.onclick=startSeason; 
nextBtn.onclick=function(){
  if (sceneQueue.length){
    showLine(sceneQueue.shift());
    if (currentEpisode) currentEpisode.linesViewed++;
    renderEpisodeNav();
    return;
  }
  const prevTotal = (currentEpisode?.total || 0);
  progressGame();
  if (sceneQueue.length && (currentEpisode?.total || 0) > prevTotal){
    showLine(sceneQueue.shift());
    if (currentEpisode) currentEpisode.linesViewed++;
    renderEpisodeNav();
  }
};

/* ===== Utils ===== */
function shuffle(a){ return a.slice().sort(()=>Math.random()-0.5); }
function clamp(v,lo,hi){ return Math.max(lo,Math.min(hi,v)); }
function initials(n){ return (n.split(/\s+/).map(x=>x[0]).join('')||'?').slice(0,2).toUpperCase(); }
function inAlliance(a,b){ return Object.values(alliances).some(L=>L.includes(a)&&L.includes(b)); }
function getElimPhase(n){ const x=jury.find(j=>j.name===n); return x?x.phase:null; }
function setRel(a,b,val){ rel[a]=rel[a]||{}; rel[b]=rel[b]||{}; rel[a][b]=val; rel[b][a]=val; }
function getRel(a,b){ return rel[a]?.[b] ?? 0; }
function relFactor(voter,target){ return clamp(1+REL_SCALE*getRel(voter,target), REL_MIN_FACTOR, 2); }
function weighted(items, fn){ const w=items.map(fn); const s=w.reduce((a,b)=>a+b,0); let r=Math.random()*s; for(let i=0;i<items.length;i++){ r-=w[i]; if(r<=0) return items[i]; } return items[items.length-1]; }
function duelWinProb(a,b){ const da=stats[a]?.challenge||8, db=stats[b]?.challenge||8; const p=1/(1+Math.exp(-LOGIT_K*(da-db))); return clamp(p,WIN_CLAMP_LO,WIN_CLAMP_HI); }

/* ===== Episode system ===== */
function ensureEpisodeForCurrentRound(){
  const tag=`Phase ${phase} R${round}`;
  if(!currentEpisode || currentEpisode._tag!==tag){
    currentEpisode={title:`Episode ${episodes.length+1} — ${tag}`, _tag:tag, linesViewed:0, total:0};
    episodes.push(currentEpisode);
    sceneQueue=[]; sceneIndex=0; renderEpisodeNav();
    showLine('(Ready) Tap “Next Scene”.');
  }
}
function addScene(text){ sceneQueue.push(text); if(currentEpisode) currentEpisode.total++; }
function showLine(text){ sceneFeed.textContent=text; }
function renderEpisodeNav(){
  epListDiv.innerHTML=episodes.map((ep,i)=>`
    <div class="epItem">
      <div class="thumb">${i+1}</div>
      <div style="flex:1">
        <div>${ep.title}</div>
        <div><small>${ep.linesViewed} / ${ep.total} scenes</small></div>
      </div>
    </div>`).join('');
}

/* ===== Preseason builders ===== */
const castGrid=document.getElementById('castGrid'), statsTable=document.getElementById('statsTable');
function preNames(){ return document.getElementById('playerInput').value.trim().split('\n').map(s=>s.trim()).filter(Boolean); }
document.getElementById('playerInput').addEventListener('input', ()=>{ if(!gameStarted){ buildStatsTable(); buildRelFocusList(); buildCastGrid(); renderRelsLive(); }});

function buildCastGrid(){
  const names=preNames(); if(!names.length){ castGrid.innerHTML=''; return; }
  if(!Object.keys(cast).length){
    const pal=["#7aa2ff","#ffa07a","#a3e635","#f472b6","#facc15","#34d399","#60a5fa","#f59e0b","#22d3ee","#c084fc","#fb7185","#93c5fd"];
    names.forEach((n,i)=> cast[n]={photo:'',color:pal[i%pal.length]});
  }
  castGrid.innerHTML=names.map(n=>{
    const c=cast[n]||{photo:'',color:'#7aa2ff'};
    return `<div class="chip" style="margin:6px 0;">
      ${c.photo?`<img class="avatar" src="${c.photo}">`:`<div class="avatar" style="background:${c.color}">${initials(n)}</div>`}
      <div style="flex:1">${n}<input type="url" class="photoUrl" data-name="${n}" placeholder="Image URL" value="${c.photo}"></div>
      <input type="color" class="color" data-name="${n}" value="${c.color}">
    </div>`;
  }).join('');
  castGrid.querySelectorAll('.photoUrl').forEach(inp=> inp.oninput=()=>{ const n=inp.dataset.name; cast[n]=cast[n]||{photo:'',color:'#7aa2ff'}; cast[n].photo=inp.value.trim(); buildCastGrid(); });
  castGrid.querySelectorAll('.color').forEach(inp=> inp.oninput=()=>{ const n=inp.dataset.name; cast[n]=cast[n]||{photo:'',color:'#7aa2ff'}; cast[n].color=inp.value; buildCastGrid(); });
}
function buildStatsTable(){
  const names=preNames();
  statsTable.innerHTML = `<table><tr><th>Player</th><th>Social</th><th>Challenge</th></tr>${
    names.map(n=>{
      const s=stats[n]?.social??8, c=stats[n]?.challenge??8;
      return `<tr><td>${n}</td>
        <td><input type="number" class="st" data-name="${n}" data-field="social" min="1" max="15" value="${s}"></td>
        <td><input type="number" class="st" data-name="${n}" data-field="challenge" min="1" max="15" value="${c}"></td></tr>`;
    }).join('')
  }</table>`;
}
function applyStatsFromInputs(){
  statsTable.querySelectorAll('.st').forEach(inp=>{
    const n=inp.dataset.name, f=inp.dataset.field, v=clamp(parseInt(inp.value||'8',10),1,15);
    stats[n]=stats[n]||{social:8,challenge:8}; stats[n][f]=v;
  });
}
document.getElementById('applyStats').onclick=applyStatsFromInputs;
document.getElementById('presetBalanced').onclick=()=>presetStats('balanced');
document.getElementById('presetSocial').onclick=()=>presetStats('social');
document.getElementById('presetChallenge').onclick=()=>presetStats('challenge');
document.getElementById('presetRandom').onclick=()=>presetStats('random');
function presetStats(which){
  const names=preNames();
  names.forEach(n=>{
    stats[n]=stats[n]||{social:8,challenge:8};
    if(which==='balanced') stats[n]={social:8,challenge:8};
    if(which==='social')   stats[n]={social:12,challenge:8};
    if(which==='challenge')stats[n]={social:8,challenge:12};
    if(which==='random')   stats[n]={social:1+Math.floor(Math.random()*15),challenge:1+Math.floor(Math.random()*15)};
  });
  buildStatsTable();
}

/* Relationships editor */
var relFocusSel=document.getElementById('relFocus'), relEditorDiv=document.getElementById('relEditor');
function buildRelFocusList(){ const names=preNames(); relFocusSel.innerHTML=names.map(n=>`<option>${n}</option>`).join(''); if(names.length) renderRelEditorFor(names[0]); }
relFocusSel.onchange=()=> renderRelEditorFor(relFocusSel.value);
function renderRelEditorFor(focus){
  const names=preNames().filter(n=>n!==focus);
  relEditorDiv.innerHTML = `<table><tr><th>Player</th><th>Score</th></tr>${
    names.map(n=>`<tr><td>${n}</td><td><input type="number" class="relSpin" data-focus="${focus}" data-target="${n}" min="-5" max="5" step="1" value="${getRel(focus,n)}"></td></tr>`).join('')
  }</table>`;
  relEditorDiv.querySelectorAll('.relSpin').forEach(sp=> sp.oninput=()=>{ const f=sp.dataset.focus,t=sp.dataset.target; setRel(f,t,clamp(parseInt(sp.value||'0',10),-5,5)); renderRelsLive(); });
}
document.getElementById('relSave').onclick=()=>{
  relEditorDiv.querySelectorAll('.relSpin').forEach(sp=>{ const f=sp.dataset.focus,t=sp.dataset.target; setRel(f,t,clamp(parseInt(sp.value||'0',10),-5,5)); });
  const names=preNames(); names.forEach(a=>names.forEach(b=>{ if(a!==b) setRel(a,b,getRel(a,b)); }));
  addScene('Saved all preseason relationships.'); renderRelsLive();
};
document.getElementById('relRandFocus').onclick=()=>{
  const f=relFocusSel.value; relEditorDiv.querySelectorAll('.relSpin').forEach(sp=>{ const t=sp.dataset.target; const v=Math.floor(-2+Math.random()*5); setRel(f,t,v); sp.value=v; });
  addScene('Randomized focus relationships for '+f+'.'); renderRelsLive();
};
document.getElementById('relClearFocus').onclick=()=>{
  const f=relFocusSel.value; relEditorDiv.querySelectorAll('.relSpin').forEach(sp=>{ const t=sp.dataset.target; setRel(f,t,0); sp.value=0; });
  addScene('Cleared focus relationships for '+f+'.'); renderRelsLive();
};
document.getElementById('relRandAll').onclick=()=>{
  const names=preNames();
  for(let i=0;i<names.length;i++) for(let j=i+1;j<names.length;j++){
    const v = Math.floor(-2 + Math.random()*5); // mild drama −2..+2
    setRel(names[i], names[j], v);
  }
  const focus = relFocusSel.value || names[0];
  renderRelEditorFor(focus);
  addScene('Randomized relationships for all players.');
  renderRelsLive();
};
document.getElementById('relClearAll').onclick=()=>{
  const names=preNames();
  for(let i=0;i<names.length;i++) for(let j=i+1;j<names.length;j++){ setRel(names[i], names[j], 0); }
  const focus = relFocusSel.value || names[0];
  renderRelEditorFor(focus);
  addScene('Cleared all relationships.');
  renderRelsLive();
};

/* ===== Start Season ===== */
function startSeason(){
  if(gameStarted) return;
  const input=preNames();
  if(input.length!==12){ alert('Please enter exactly 12 players.'); return; }

  players=input.slice(); initialOrder=input.slice(); knownVoters=input.slice();
  players.forEach(p=>{
    keys[p]=[]; stats[p]=stats[p]||{social:8,challenge:8}; rel[p]=rel[p]||{};
    cast[p]=cast[p]||{photo:'',color:'#7aa2ff'};
    wins[p]=0; losses[p]=0; keysEarned[p]={P1:0,P2:0}; votesGiven[p]=0; votesReceived[p]=0; juryKeysReceived[p]=0;
  });

  gameStarted=true;
  startBtn.style.display='none'; nextBtn.style.display='inline-block';
  document.getElementById('seasonControls').style.display='none';
  document.getElementById('castBox').style.display='none';
  document.getElementById('preseasonBox').style.display='none';

  generateAlliancesPreset();
  phase=1; round=1;
  ensureEpisodeForCurrentRound();
  addScene('Season begins. Phase 1: The Key Quest.');
  addScene('Alliances formed: '+Object.entries(alliances).map(e=>`${e[0]}: ${e[1].join(', ')}`).join(' | '));
}

/* ===== Alliances ===== */
function presetBias(kind){
  if(kind==='loyal') return {extraSameAlliancePick:0.2, fluid:false, duo:false, loners:false};
  if(kind==='duos')  return {duo:true};
  if(kind==='loners')return {loners:true};
  return {fluid:true, extraSameAlliancePick:0.15};
}
function generateAlliancesPreset(){
  alliances={};
  const bias=presetBias(SEASON.preset);
  const labels='ABCDEFGHIJKLMNOPQRSTUVWXYZ'.slice(0, (bias.duo?6 : bias.loners?3 : 4)).split('');
  labels.forEach(k=> alliances[k]=[]);
  const sh=shuffle(players);
  if(bias.duo){ for(let i=0;i<sh.length;i+=2){ alliances[labels[(i/2)%labels.length]].push(sh[i], sh[i+1]); } }
  else if(bias.loners){ for(let i=0;i<sh.length;i++){ alliances[labels[i%labels.length]].push(sh[i]); } }
  else {
    for(let i=0;i<sh.length;i++){ alliances[labels[i%labels.length]].push(sh[i]); }
    if(bias.fluid) for(let i=0;i<players.length;i++) if(Math.random()<0.18){
      const p=players[i]; const other=labels[Math.floor(Math.random()*labels.length)];
      if(!alliances[other].includes(p)) alliances[other].push(p);
    }
  }
  updateAlliances();
}

/* ===== Displays ===== */
function updateAlliances(){
  const box=document.getElementById('alliancesList');
  box.innerHTML = Object.entries(alliances).map(e=>`<div><strong>${e[0]}</strong>: ${e[1].join(', ')}</div>`).join('');
}
function updateProgress(){
  const chart=document.getElementById('progressChart');
  const everyone=players.concat(eliminated.filter(p=>!players.includes(p)));
  chart.innerHTML = `<table><tr><th>Player</th><th>P1</th><th>P2</th><th>Final</th><th>W</th><th>L</th></tr>${
    everyone.map(p=>{
      const p1=keys[p].includes('P1')?'✔':'—', p2=keys[p].includes('P2')?'✔':'—', pf=(finalists.includes(p)?'✔':'—');
      return `<tr><td>${p}</td><td>${p1}</td><td>${p2}</td><td>${pf}</td><td>${wins[p]||0}</td><td>${losses[p]||0}</td></tr>`;
    }).join('')
  }</table>`;
}
function renderRelsLive(){
  const wrap=document.getElementById('relsLive'); if(!players.length){ wrap.innerHTML=''; return; }
  const pairs=[], seen={};
  for(let i=0;i<players.length;i++)for(let j=0;j<players.length;j++){
    const a=players[i], b=players[j]; if(a===b) continue; const k=[a,b].sort().join('|'); if(seen[k]) continue; seen[k]=1;
    pairs.push({a,b,v:getRel(a,b)});
  }
  pairs.sort((x,y)=>Math.abs(y.v)-Math.abs(x.v));
  const bonds=pairs.filter(p=>p.v>0).slice(0,5), feuds=pairs.filter(p=>p.v<0).slice(0,5);
  wrap.innerHTML = `<div><strong>Bonds</strong><br/>${bonds.length?bonds.map(p=>`${p.a} ↔ ${p.b} (+${p.v})`).join('<br/>'):'<span class="hint">None</span>'}
    <hr style="border-color:var(--border)"><strong>Tensions</strong><br/>${feuds.length?feuds.map(p=>`${p.a} ↔ ${p.b} (${p.v})`).join('<br/>'):'<span class="hint">None</span>'}</div>`;
}
function renderMasterVoteTable(){
  const wrap=document.getElementById('votingMatrix');
  let html='<div style="overflow:auto"><table><thead><tr><th>Voter</th>';
  voteColumns.forEach(c=> html+=`<th>${c.label}</th>`); html+='</tr></thead><tbody>';
  const active=players.slice(), p3=eliminated.filter(n=>getElimPhase(n)===3), p2=eliminated.filter(n=>getElimPhase(n)===2), p1=eliminated.filter(n=>getElimPhase(n)===1);
  const row=(name)=>{ html+=`<tr><td>${name}</td>`; voteColumns.forEach(c=> html+=`<td>${c.values[name]||'—'}</td>`); html+='</tr>'; };
  active.forEach(row); p3.forEach(row); p2.forEach(row); p1.forEach(row);
  html+='<tr><th>Result</th>'; voteColumns.forEach(c=> html+=`<th>${c.result||''}</th>`); html+='</tr></tbody></table></div>';
  wrap.innerHTML=html;
}
function addVoteColumn(label,phaseTag,roundNo,voters,votePairs,result,lockUser){
  const values={}; knownVoters.forEach(v=>values[v]='—');
  votePairs.forEach(([v,to])=> values[v]=to);
  if(lockUser) values[lockUser]='LOCKPICK';
  voteColumns.push({label,phaseTag,roundNo,result,values}); renderMasterVoteTable();
}

/* ===== Social Events ===== */
function triggerSocialEvents(contextTag){
  if(!players.length) return;
  const num = Math.floor(Math.random()*3); // 0–2 events
  for(let k=0;k<num;k++){
    const a = players[Math.floor(Math.random()*players.length)];
    let b = players[Math.floor(Math.random()*players.length)];
    if (a===b) continue;
    const ev = weighted(EVENT_LIBRARY, e=>e.w);
    const isBond = ev.type==='bond';
    const delta = isBond ? +1 : -1;
    setRel(a,b, clamp(getRel(a,b)+delta,-5,5));
    addScene(`Event • ${contextTag}: ${ev.text(a,b)}`);
  }
  renderRelsLive();
}

/* ===== Relationship change helpers (combined line) ===== */
function postVoteRelChanges(winner, drawn, votePairs){
  const bumps=[], drops=[];
  const targetedBy = votePairs.filter(([_,to])=>to===winner).map(([v,_])=>v);

  targetedBy.forEach(v=>{
    if (inAlliance(v, winner)) { setRel(v,winner, clamp(getRel(v,winner)+1,-5,5)); bumps.push(`${v}→${winner} +1 (alliance support)`); }
  });
  drawn.filter(p=>p!==winner).forEach(p=>{
    if (!inAlliance(p, winner)) { setRel(p,winner, clamp(getRel(p,winner)-1,-5,5)); drops.push(`${p}→${winner} -1 (resentment)`); }
  });

  renderRelsLive();
  const line = (!bumps.length && !drops.length)
    ? 'No noticeable post‑vote ripples.'
    : `Post‑vote ripples — Bonds: ${bumps.join(' • ') || '—'} | Tensions: ${drops.join(' • ') || '—'}`;
  addScene(line);
}
function postPickRelChanges(picker, picks, hadAllyOption){
  const bumps=[], drops=[];
  picks.forEach(o=>{
    if (inAlliance(picker,o)){ setRel(picker,o, clamp(getRel(picker,o)+1,-5,5)); bumps.push(`${picker}→${o} +1 (trusted ally)`); }
    else { setRel(picker,o, clamp(getRel(picker,o)-1,-5,5)); drops.push(`${picker}→${o} -1 (targeted)`); }
  });
  if (hadAllyOption && picks.every(o=>!inAlliance(picker,o))){
    const allies = players.filter(p=>p!==picker && inAlliance(picker,p));
    allies.forEach(a=> setRel(picker,a, clamp(getRel(picker,a)-1,-5,5)));
    if (allies.length) drops.push(`${picker}→allies (${allies.join(', ')}) -1 (snub)`);
  }

  renderRelsLive();
  const line = (!bumps.length && !drops.length)
    ? 'No noticeable post‑pick ripples.'
    : `Post‑pick ripples — Bonds: ${bumps.join(' • ') || '—'} | Tensions: ${drops.join(' • ') || '—'}`;
  addScene(line);
}

/* ===== Driver ===== */
function progressGame(){
  updateAlliances(); updateProgress(); renderRelsLive(); renderEpisodeNav();

  if(phase===1){ runPhase1(); return; }
  if(phase===2){ runPhase2(); return; }
  if(phase===3){ runPhase3(); return; }
  if(phase===4){ runFinale(); return; }
}

/* ===== Core voting ===== */
function simulateVote(voters, eligible){
  const out=[];
  voters.forEach(v=>{
    const choices=eligible.filter(p=>p!==v);
    const al=choices.filter(c=>inAlliance(v,c));
    const prioritize = al.length>0 && Math.random()<(ALLY_PREFERENCE_RATE + (SEASON.preset==='loyal'?0.2:(SEASON.preset==='fluid'?0.15:0)));
    const pool = prioritize? al : choices;
    const baseAlpha = prioritize? ALPHA_SOCIAL : 0.5*ALPHA_SOCIAL;
    const pick = weighted(pool, c=>{
      const s=(stats[c]?.social||8);
      const j=VOTE_JITTER_MIN + Math.random()*(VOTE_JITTER_MAX - VOTE_JITTER_MIN);
      return Math.pow(s,baseAlpha)*j*relFactor(v,c);
    });
    votesGiven[v]=(votesGiven[v]||0)+1; votesReceived[pick]=(votesReceived[pick]||0)+1;
    out.push([v,pick]);
  });
  return out;
}
function tally(votePairs, eligible){
  const counts={}; eligible.forEach(p=>counts[p]=0); votePairs.forEach(([_,to])=>{ if(counts[to]!=null) counts[to]++; });
  const max=Math.max(...Object.values(counts)); const tied=Object.keys(counts).filter(k=>counts[k]===max);
  return [tied[0], tied, counts];
}

/* ===== Phase 1 ===== */
function runPhase1(){
  // End gate + elimination to jury
  const p1Count=Object.values(keys).reduce((a,k)=>a+(k.includes?.('P1')?1:0),0);
  if(round>4 || p1Count>=8){
    const advancing=players.filter(p=>keys[p].includes('P1'));
    const phaseOut=players.filter(p=>!keys[p].includes('P1'));
    phaseOut.forEach(p=>{ eliminated.push(p); jury.push({name:p,phase:1}); });
    players=advancing.slice();
    addScene('Phase 1 complete. Eliminated: '+(phaseOut.join(', ')||'none'));
    phase=2; round=1; return;
  }

  if(p1_step===0){
    ensureEpisodeForCurrentRound();

    const eligible=players.filter(p=>!keys[p].includes('P1'));
    p1_drawn=shuffle(eligible).slice(0,4);
    addScene('Drawn: '+p1_drawn.join(', '));

    triggerSocialEvents('around the draw');

    if(!SEASON.noLockpick && !lockpickFound && Math.random()<0.33){
      lockpickHolder=p1_drawn[Math.floor(Math.random()*p1_drawn.length)]; lockpickFound=true;
      addScene('LOCKPICK discovered by '+lockpickHolder+'.');
    }

    p1_votePairs=simulateVote(players, p1_drawn);
    let [winner] = tally(p1_votePairs, p1_drawn);
    p1_lockUser=null;
    if(!SEASON.noLockpick && lockpickHolder && !lockpickUsed && p1_drawn.includes(lockpickHolder)){
      const mustUse=(round===4 && !keys[lockpickHolder].includes('P1'));
      if(mustUse || Math.random()<0.2){ winner=lockpickHolder; p1_lockUser=lockpickHolder; lockpickUsed=true; addScene(lockpickHolder+' uses LOCKPICK to override.'); }
    }
    p1_winner=winner;
    addVoteColumn(`P1 R${round}`,'P1',round,players,p1_votePairs,p1_winner,p1_lockUser);
    addScene(`${p1_winner} wins the vote key.`);
    keys[p1_winner].push('P1'); keysEarned[p1_winner].P1=(keysEarned[p1_winner].P1||0)+1; wins[p1_winner]=(wins[p1_winner]||0)+1;

    p1_step=1; return;
  }
  if(p1_step===1){
    postVoteRelChanges(p1_winner, p1_drawn, p1_votePairs);
    p1_step=2; return;
  }
  if(p1_step===2){
    const others=p1_drawn.filter(p=>p!==p1_winner && !keys[p].includes('P1'));
    if(others.length){
      const w=weighted(others, p=>Math.pow(stats[p]?.challenge||8,BETA_CHALLENGE));
      p1_chalWin=w;
      addScene(`Challenge: ${others.join(' vs ')} → ${w} wins the challenge key.`);
      keys[w].push('P1'); keysEarned[w].P1=(keysEarned[w].P1||0)+1; 
      wins[w]=(wins[w]||0)+1; 
      // count losses to others (duel record parity)
      others.filter(x=>x!==w).forEach(l=>{ losses[l]=(losses[l]||0)+1; });
    } else {
      addScene('No challenge key this round.');
    }
    updateProgress(); renderRelsLive(); renderMasterVoteTable();
    round++; p1_step=0; return;
  }
}

/* ===== Phase 2 ===== */
function runPhase2(){
  // End gate + elimination to jury
  const p2Count=Object.values(keys).reduce((a,k)=>a+(k.includes?.('P2')?1:0),0);
  if(round>4 || p2Count>=4){
    const advancing=players.filter(p=>keys[p].includes('P2'));
    const phaseOut=players.filter(p=>!keys[p].includes('P2'));
    phaseOut.forEach(p=>{ eliminated.push(p); jury.push({name:p,phase:2}); });
    players=advancing.slice();
    addScene('Phase 2 complete. Eliminated: '+(phaseOut.join(', ')||'none'));
    phase=3; round=1; return;
  }

  if(p2_step===0){
    ensureEpisodeForCurrentRound();

    addScene(`Phase 2 — Round ${round}`);
    p2_noKey=players.filter(p=>!keys[p].includes('P2'));
    if(p2_noKey.length<2){ phase=3; round=1; addScene('Not enough no‑key players. Moving to Phase 3.'); return; }

    p2_votePairs=simulateVote(players,p2_noKey);
    let [winner] = tally(p2_votePairs,p2_noKey);
    p2_lockUser=null;
    if(!SEASON.noLockpick && lockpickHolder && !lockpickUsed && p2_noKey.includes(lockpickHolder) && !keys[lockpickHolder].includes('P2')){
      if(Math.random()<0.6){ winner=lockpickHolder; p2_lockUser=lockpickHolder; lockpickUsed=true; addScene(lockpickHolder+' auto‑wins via LOCKPICK.'); }
    }
    p2_winner=winner;
    addVoteColumn(`P2 R${round}`,'P2',round,players,p2_votePairs,p2_winner,p2_lockUser);
    addScene(`${p2_winner} wins the vote and will choose ${SEASON.doubleDuel?'two opponents (3‑way duel).':'an opponent.'}`);

    triggerSocialEvents('post‑vote');

    p2_step=1; return;
  }
  if(p2_step===1){
    postVoteRelChanges(p2_winner, p2_noKey, p2_votePairs);
    p2_step=2; return;
  }
  if(p2_step===2){
    const candidates=p2_noKey.filter(p=>p!==p2_winner);
    function chooseOpponent(fromPool){
      const allies=fromPool.filter(p=>inAlliance(p,p2_winner));
      const non=fromPool.filter(p=>!inAlliance(p,p2_winner));
      if(allies.length && Math.random()<0.55){
        const pick=weighted(allies, p=>1/Math.max(1,(stats[p]?.challenge||8)) * relFactor(p2_winner,p));
        return {opp:pick,why:'keeps key in alliance'};
      }
      if(non.length){
        const pick=weighted(non, p=>Math.pow(1/Math.max(1,(stats[p]?.challenge||8)),GAMMA_BEATABLE)*relFactor(p2_winner,p));
        return {opp:pick,why:'chooses someone they can beat'};
      }
      const pick=weighted(fromPool, p=>relFactor(p2_winner,p));
      return {opp:pick,why:'neutral pick'};
    }
    p2_picks=[]; let pool=candidates.slice();
    const first=chooseOpponent(pool); p2_picks.push(first); pool=pool.filter(x=>x!==first.opp);
    if(SEASON.doubleDuel && pool.length){ const second=chooseOpponent(pool); p2_picks.push(second); }
    if(p2_picks.length===1){
      p2_reasonText=first.why+'.'; addScene(`${p2_winner} chooses ${first.opp} — ${p2_reasonText}`);
    }else{
      p2_reasonText=`${p2_picks[0].why}; also ${p2_picks[1].why}.`;
      addScene(`${p2_winner} chooses ${p2_picks[0].opp} and ${p2_picks[1].opp} — ${p2_reasonText} (3‑way duel).`);
    }

    triggerSocialEvents('after picks');

    p2_step=3; return;
  }
  if(p2_step===3){
    const hadAllyOption = p2_noKey.some(p=>p!==p2_winner && inAlliance(p2_winner,p));
    postPickRelChanges(p2_winner, p2_picks.map(x=>x.opp), hadAllyOption);
    p2_step=4; return;
  }
  if(p2_step===4){
    if(!SEASON.doubleDuel || p2_picks.length===1){
      const a=p2_winner, b=p2_picks[0].opp, p=duelWinProb(a,b);
      const win=Math.random()<p?a:b, lose=(win===a?b:a);
      keys[win].push('P2'); keysEarned[win].P2=(keysEarned[win].P2||0)+1;
      wins[win]=(wins[win]||0)+1; losses[lose]=(losses[lose]||0)+1;
      addScene(`${win} defeats ${lose} and earns a Phase 2 key.`);
    } else {
      const a=p2_winner, b=p2_picks[0].opp, c=p2_picks[1].opp;
      const weight=x=>(stats[x]?.challenge||8)*(0.85+Math.random()*0.3);
      const wa=weight(a), wb=weight(b), wc=weight(c), tot=wa+wb+wc;
      let r=Math.random()*tot; const win=(r<wa)?a:((r-wa)<wb?b:c);
      keys[win].push('P2'); keysEarned[win].P2=(keysEarned[win].P2||0)+1;
      wins[win]=(wins[win]||0)+1; [a,b,c].filter(x=>x!==win).forEach(l=> losses[l]=(losses[l]||0)+1);
      addScene(`${a}, ${b}, and ${c} battle in a 3‑way duel — ${win} wins the Phase 2 key.`);
    }
    updateProgress(); renderMasterVoteTable();
    round++; p2_step=0; return;
  }
}

/* ===== Phase 3 ===== */
function runPhase3(){
  if(p3_step===0){
    ensureEpisodeForCurrentRound();

    triggerSocialEvents('endgame tension');
    addScene('Phase 3 — Final Cut: Vote');

    const raw=simulateVote(players,players), pairs=[];
    raw.forEach(([v,to])=>{
      if(v===to){
        const choices=players.filter(p=>p!==v);
        const pick=weighted(choices, c=> (stats[c]?.social||8) * relFactor(v,c));
        pairs.push([v,pick]);
      } else pairs.push([v,to]);
    });
    let [voteWinner] = tally(pairs,players);

    // F4 special ties
    if(players.length===4){
      const counts={}; players.forEach(p=>counts[p]=0); pairs.forEach(([_,t])=>counts[t]++);
      const vals=Object.values(counts); const max=Math.max(...vals);
      const tiedTop=Object.keys(counts).filter(p=>counts[p]===max);
      const allEq=vals.every(v=>v===vals[0]);
      if(allEq){
        addScene('Final 4 four‑way tie! All four compete; top three advance.');
        const perf=players.map(p=>({p,score:(stats[p]?.challenge||8)*(0.8+Math.random()*0.4)})).sort((a,b)=>b.score-a.score);
        const advancing=[perf[0].p,perf[1].p,perf[2].p], fourth=perf[3].p;
        finalists=advancing.slice(); eliminated.push(fourth); jury.push({name:fourth,phase:3});
        addScene('Top‑3: '+advancing.join(', ')+'. Eliminated: '+fourth+'.');
        phase=4; round=1; return;
      }
      if(tiedTop.length===2){
        const non=players.filter(p=>!tiedTop.includes(p));
        finalists=non.slice(); addScene('F4 two‑way tie: '+tiedTop[0]+' vs '+tiedTop[1]+'. Others advance: '+non.join(', ')+'.');
        const a=tiedTop[0], b=tiedTop[1], p=duelWinProb(a,b), dW=Math.random()<p?a:b, dL=(dW===a?b:a);
        finalists.push(dW); eliminated.push(dL); jury.push({name:dL,phase:3});
        addScene(dW+' wins tiebreak duel. '+dL+' joins the jury.');
        phase=4; round=1; return;
      }
    }

    p3_voteWinner=voteWinner; addScene(voteWinner+' wins the vote and becomes a finalist.');
    const avail=players.filter(p=>p!==voteWinner), ally=avail.filter(p=>inAlliance(p,voteWinner));
    p3_chosenAlly = weighted(ally.length?ally:avail, p=> (stats[p]?.social||8)*relFactor(voteWinner,p));
    addVoteColumn('P3 Vote','P3',1,players,pairs,voteWinner,null);
    p3_duelists=players.filter(p=>p!==voteWinner && p!==p3_chosenAlly);
    addScene(voteWinner+' selects '+p3_chosenAlly+'. The remaining two will duel for the last spot.');
    finalists=[p3_voteWinner,p3_chosenAlly]; p3_step=1; return;
  }
  if(p3_step===1){
    const [a,b]=p3_duelists, p=duelWinProb(a,b); const dW=Math.random()<p?a:b, dL=(dW===a?b:a);
    finalists.push(dW); eliminated.push(dL); jury.push({name:dL,phase:3});
    wins[dW]=(wins[dW]||0)+1; losses[dL]=(losses[dL]||0)+1;
    addScene(dW+' wins the final duel. '+dL+' joins the jury.');
    phase=4; round=1; p3_step=0; return;
  }
}

/* ===== Finale ===== */
var finaleState=null, finaleStep=0;
function runFinale(){
  ensureEpisodeForCurrentRound();

  if (!finaleState){
    if (finalists.length < 2){ addScene('Finale error: not enough finalists.'); return; }

    finaleState = { finalistKeys:{}, chosenVaults:{}, juryMatrix:{}, winner:null };
    finalists.forEach(f=> finaleState.finalistKeys[f]=3);

    // Always distribute jury keys
    finaleState.juryMatrix = distributeJuryKeys(finalists, jury, finaleState.finalistKeys);
    displayJuryMatrix(finaleState.juryMatrix);

    // Pick vaults calibrated to perceived strength
    const support={}, maxS = finalists.reduce((m,f)=> {
      let s = 0;
      jury.forEach(j=>{ const cap=(j.phase===1?1:(j.phase===2?2:4)); if(inAlliance(j.name,f)) s+=cap; });
      s += 0.4*(stats[f]?.social||8);
      support[f]=s; return Math.max(m,s);
    },1);
    const expect={}; Object.keys(support).forEach(f=> expect[f]=Math.round(6+(support[f]/maxS)*6));
    finaleState.chosenVaults = pickVaults(expect);

    addScene('Jury awards keys. Next: vault choices.'); 
    return;
  }

  if (finaleStep===0){
    const s=[]; finalists.forEach(f=> s.push(f+' → vault '+finaleState.chosenVaults[f]));
    addScene('Vault choices: '+s.join(' | '));
    finalists.forEach(f=> addScene(f+' has '+finaleState.finalistKeys[f]+' keys.') );
    const ranking = finalists.map(n=>({name:n,keys:finaleState.finalistKeys[n],vault:finaleState.chosenVaults[n]}))
                             .sort((a,b)=>b.vault-a.vault);
    finaleState.winner = ranking.find(r=>r.keys>=r.vault) || null;
    finaleStep=1; 
    return;
  }

  if (finaleStep===1){
    if (finaleState.winner){
      addScene(`${finaleState.winner.name} opens the ${finaleState.winner.vault}-key vault with ${finaleState.winner.keys} keys and wins!`);
    } else {
      const defaultWinner = jury.find(j=>j.phase===3)?.name || finalists[0];
      addScene(`No vault opens. ${defaultWinner} wins by default.`);
    }
    nextBtn.textContent='Simulate Again'; nextBtn.onclick=()=>location.reload();
  }
}
function pickVaults(expect){
  const avail=vaults.slice(), picked={}, order=Object.keys(expect).sort((a,b)=>expect[b]-expect[a]);
  order.forEach(f=>{
    let best=avail[0], bestDiff=1e9, idx=0;
    for(let j=0;j<avail.length;j++){ const v=avail[j], d=Math.abs(v-expect[f]); if(d<bestDiff){ bestDiff=d; best=v; idx=j; } }
    picked[f]=best; avail.splice(idx,1);
  });
  return picked;
}
function distributeJuryKeys(finalists,jury,finalistKeys){
  const pool=[]; jury.forEach(j=>{ const cap=(j.phase===1?1:(j.phase===2?2:4)); for(let k=0;k<cap;k++) pool.push(j.name); });
  shuffle(pool).slice(0,16).forEach(jName=>{
    const base={}; finalists.forEach(f=> base[f]= (inAlliance(jName,f)?1.3:1.0) * (1 + 0.06*(stats[f]?.social||8)) );
    const pick=weighted(finalists, f=>base[f]); finalistKeys[pick]+=1;
  });
  const jm={}; jury.forEach(j=>{ jm[j.name]={}; finalists.forEach(f=> jm[j.name][f]=0); });
  const counts={}; finalists.forEach(f=>counts[f]=finalistKeys[f]-3);
  const names=Object.keys(jm); let idx=0; finalists.forEach(f=>{ for(let k=0;k<counts[f];k++){ const j=names[idx%names.length]; jm[j][f] += 1; idx++; } });
  return jm;
}

/* ===== Init preseason UIs ===== */
buildCastGrid(); buildStatsTable(); buildRelFocusList(); renderEpisodeNav();
</script>
</body>
</html>