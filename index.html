<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Vault Simulator — Season Controls + 3‑Way Duel</title>
<style>
  :root{
    --bg:#0f1115; --panel:#161a22; --panel2:#1c2130; --muted:#2a2f3a; --text:#e5e7eb; --sub:#aeb4c0; 
    --accent:#7aa2ff; --good:#6ee7b7; --warn:#fbbf24; --bad:#f87171; --border:#2b3340;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  h1{margin:0;font-size:20px}
  h2{margin:0 0 10px;font-size:16px}
  textarea,button,input,select{width:100%;padding:12px;margin-top:8px;border-radius:10px;border:1px solid var(--border);background:var(--panel);color:var(--text);font-size:16px}
  button{cursor:pointer} button:hover{background:var(--panel2)}
  .app{display:grid;grid-template-columns:280px 1fr;min-height:100vh}
  .sidebar{background:var(--panel);border-right:1px solid var(--border);padding:14px 12px;display:flex;flex-direction:column;gap:12px;position:sticky;top:0;height:100vh}
  .brand{display:flex;align-items:center;justify-content:space-between;gap:10px}
  .hamburger{display:none;font-size:18px;padding:8px 10px;border-radius:8px;background:var(--panel2)}
  .epList{flex:1;overflow:auto;border:1px solid var(--border);border-radius:10px}
  .epItem{padding:10px;border-bottom:1px solid var(--border);display:flex;gap:10px;align-items:center}
  .epItem:last-child{border-bottom:none}
  .thumb{width:36px;height:36px;border-radius:8px;background:var(--muted);display:flex;align-items:center;justify-content:center;font-size:12px}
  .spoiler{opacity:.45}
  .main{padding:18px;display:grid;gap:16px}
  .box{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:14px}
  .row{display:flex;gap:14px;flex-wrap:wrap}
  .col{flex:1 1 280px}
  pre{white-space:pre-wrap;background:var(--bg);border:1px solid var(--border);border-radius:10px;padding:10px;min-height:200px;max-height:260px;overflow:auto}
  table{width:100%;border-collapse:collapse}
  th,td{border:1px solid var(--border);padding:8px;text-align:center;white-space:nowrap}
  th{background:var(--panel2)}
  .btnrow{display:flex;gap:10px;flex-wrap:wrap}
  .chip{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--border);padding:6px 8px;border-radius:8px}
  .avatar{width:22px;height:22px;border-radius:6px;object-fit:cover;background:var(--muted);display:inline-flex;align-items:center;justify-content:center;font-size:11px}
  .hint{font-size:13px;color:var(--sub)}
  .toggle{display:flex;align-items:center;gap:8px;font-size:13px;color:var(--sub)}

  /* Mobile */
  @media (max-width: 900px){
    .app{grid-template-columns:1fr}
    .sidebar{position:relative;height:auto}
    .hamburger{display:inline-block}
    .sidebar.collapsed .collapsible-area{display:none}
    .main{padding:12px}
    textarea,button,input,select{font-size:16px} /* avoid iOS zoom */
    pre{min-height:180px}
  }
</style>
</head>
<body>
<div class="app">
  <!-- Sidebar -->
  <aside class="sidebar collapsed" id="sidebar">
    <div class="brand">
      <h1>Vault Episodes</h1>
      <button class="hamburger" id="hamburger">☰</button>
    </div>
    <div class="collapsible-area">
      <label class="toggle"><input type="checkbox" id="spoilerToggle"/> Spoiler‑free nav</label>

      <!-- Season Controls -->
      <div class="box" id="seasonControls">
        <h2>Season Controls</h2>
        <label>Alliance Preset</label>
        <select id="alliancePreset">
          <option value="fluid">Fluid webs (default)</option>
          <option value="loyal">Loyal blocs</option>
          <option value="duos">Duo‑centric</option>
          <option value="loners">Loners thrive</option>
        </select>
        <hr style="border-color:var(--border);margin:12px 0">
        <h3 style="margin:0 0 6px;font-size:15px">Twists (season‑wide)</h3>
        <label class="toggle">
          <input type="checkbox" id="tw_noLockpick"/>
          No Lockpick this season
        </label>
        <label class="toggle">
          <input type="checkbox" id="tw_doubleDuel"/>
          Double Duel (vote winner faces TWO in a single 3‑way duel)
        </label>
        <div class="hint">These lock and disappear after you press <em>Start Season</em>.</div>
      </div>

      <div class="epList" id="epList"></div>
    </div>
  </aside>

  <!-- Main -->
  <main class="main">
    <div class="box">
      <div class="row">
        <div class="col">
          <label><strong>Enter 12 Players (one per line)</strong></label>
          <textarea id="playerInput" rows="12" placeholder="Player 1&#10;Player 2&#10;..."></textarea>
          <div class="btnrow" style="margin-top:6px">
            <button id="startBtn">Start Season</button>
            <button id="nextBtn" style="display:none;">Next Scene ▶</button>
          </div>
          <div class="hint">Episode mapping: <strong>Each round = 1 episode.</strong> Episode 1 is Phase 1 Round 1. Finale is its own episode.</div>
        </div>
        <div class="col" id="castBox">
          <h2>Cast Photos & Colors</h2>
          <div id="castGrid"></div>
        </div>
      </div>
    </div>

    <div class="box" id="preseasonBox">
      <h2>Preseason: Stats & Relationships</h2>
      <div class="row">
        <div class="col">
          <h3 style="margin:0 0 6px">Player Stats</h3>
          <div id="statsTable"></div>
          <div class="btnrow" style="margin-top:6px">
            <button id="presetBalanced">Balanced</button>
            <button id="presetSocial">Social‑heavy</button>
            <button id="presetChallenge">Challenge‑heavy</button>
            <button id="presetRandom">Randomize All</button>
            <button id="applyStats">Apply Stats</button>
          </div>
          <div class="hint">Range: 1–15 (default 8/8). Hidden during play.</div>
        </div>
        <div class="col">
          <h3 style="margin:0 0 6px">Relationships (−5…+5)</h3>
          <div class="row" style="align-items:center">
            <label>Focus</label>
            <select id="relFocus"></select>
          </div>
          <div id="relEditor" style="margin-top:6px"></div>
          <div class="btnrow" style="margin-top:6px">
            <button id="relSave">Save (All)</button>
            <button id="relRandFocus">Randomize Focus</button>
            <button id="relClearFocus">Clear Focus</button>
            <button id="relRandAll">Randomize All</button>
            <button id="relClearAll">Clear All</button>
          </div>
        </div>
      </div>
    </div>

    <div class="box">
      <h2>Round Events (Scene feed)</h2>
      <pre id="sceneFeed">(Scene ready) Tap “Next Scene” to begin.</pre>
    </div>

    <div class="row">
      <div class="box col">
        <h2>Alliances</h2>
        <div id="alliancesList"></div>
      </div>
      <div class="box col">
        <h2>Progress</h2>
        <div id="progressChart"></div>
      </div>
    </div>

    <div class="row">
      <div class="box col">
        <h2>Voting Matrix (Season)</h2>
        <div id="votingMatrix"></div>
        <div class="hint">LOCKPICK appears if used. Ordering: active → P3 elim → P2 elim → P1 elim.</div>
      </div>
      <div class="box col">
        <h2>Relationships (Live)</h2>
        <div id="relsLive"></div>
      </div>
    </div>

    <div class="box">
      <h2>Jury Key Distribution</h2>
      <div id="juryMatrix"></div>
    </div>
  </main>
</div>

<script>
/* ===== Season Options ===== */
var SEASON = { preset:'fluid', noLockpick:false, doubleDuel:false };

/* ===== Tunables ===== */
var ALPHA_SOCIAL=0.65, BETA_CHALLENGE=1.0, GAMMA_BEATABLE=1.2;
var LOGIT_K=0.7, WIN_CLAMP_LO=0.15, WIN_CLAMP_HI=0.85;
var VOTE_JITTER_MIN=0.8, VOTE_JITTER_MAX=1.2, ALLY_PREFERENCE_RATE=0.6;
var REL_SCALE=0.08, REL_MIN_FACTOR=0.3;

/* ===== State ===== */
var players=[], initialOrder=[], phase=1, round=1;
var alliances={}, keys={}, jury=[], finalists=[], eliminated=[];
var lockpickHolder=null, lockpickUsed=false, lockpickFound=false;
var voteColumns=[], knownVoters=[], vaults=[]; for(var i=3;i<=22;i++) vaults.push(i);
var gameStarted=false;

/* Episodes */
var episodes=[], currentEpisode=null, sceneQueue=[], sceneIndex=0, spoilerFree=false;

/* Stats / rel / cast */
var stats={}, rel={}, cast={};
var wins={}, losses={}, keysEarned={}, votesGiven={}, votesReceived={}, juryKeysReceived={};

/* Step temps */
var p1_step=0, p2_step=0, p3_step=0;
var p1_drawn=[], p1_votePairs=[], p1_winner=null, p1_lockUser=null, p1_challengeWinner=null;
var p2_noKey=[], p2_votePairs=[], p2_winner=null, p2_lockUser=null, p2_picks=[], p2_reasonText='';
var p3_voteWinner=null, p3_chosenAlly=null, p3_duelists=[];

/* ===== DOM ===== */
var sidebar=document.getElementById('sidebar');
document.getElementById('hamburger').onclick=function(){ sidebar.classList.toggle('collapsed'); };
var startBtn=document.getElementById('startBtn'), nextBtn=document.getElementById('nextBtn');
var sceneFeed=document.getElementById('sceneFeed'), epListDiv=document.getElementById('epList');
document.getElementById('spoilerToggle').onchange=function(){ spoilerFree=this.checked; renderEpisodeNav(); };
document.getElementById('alliancePreset').onchange=function(){ SEASON.preset=this.value; };
document.getElementById('tw_noLockpick').onchange=function(){ SEASON.noLockpick=this.checked; };
document.getElementById('tw_doubleDuel').onchange=function(){ SEASON.doubleDuel=this.checked; };
startBtn.onclick=startSeason; nextBtn.onclick=nextSceneClick;

/* ===== Utils ===== */
function shuffle(a){ return a.slice().sort(()=>Math.random()-0.5); }
function clamp(v,lo,hi){ return Math.max(lo,Math.min(hi,v)); }
function initials(n){ return (n.split(/\s+/).map(x=>x[0]).join('')||'?').slice(0,2).toUpperCase(); }
function inAlliance(a,b){ return Object.values(alliances).some(L=>L.includes(a)&&L.includes(b)); }
function getElimPhase(n){ const x=jury.find(j=>j.name===n); return x?x.phase:null; }
function setRel(a,b,val){ rel[a]=rel[a]||{}; rel[b]=rel[b]||{}; rel[a][b]=val; rel[b][a]=val; }
function getRel(a,b){ return rel[a]?.[b] ?? 0; }
function relFactor(voter,target){ return clamp(1+REL_SCALE*getRel(voter,target), REL_MIN_FACTOR, 2); }
function weighted(items, fn){ const w=items.map(fn); const s=w.reduce((a,b)=>a+b,0); let r=Math.random()*s; for(let i=0;i<items.length;i++){ r-=w[i]; if(r<=0) return items[i]; } return items[items.length-1]; }
function duelWinProb(a,b){ const da=stats[a]?.challenge||8, db=stats[b]?.challenge||8; const p=1/(1+Math.exp(-LOGIT_K*(da-db))); return clamp(p,WIN_CLAMP_LO,WIN_CLAMP_HI); }

/* ===== Preseason builders ===== */
const castGrid=document.getElementById('castGrid'), statsTable=document.getElementById('statsTable');
function preNames(){ return document.getElementById('playerInput').value.trim().split('\n').map(s=>s.trim()).filter(Boolean); }
document.getElementById('playerInput').addEventListener('input', ()=>{ if(!gameStarted){ buildStatsTable(); buildRelFocusList(); buildCastGrid(); renderRelsLive(); }});

function buildCastGrid(){
  const names=preNames(); if(!names.length){ castGrid.innerHTML=''; return; }
  if(!Object.keys(cast).length){
    const pal=["#7aa2ff","#ffa07a","#a3e635","#f472b6","#facc15","#34d399","#60a5fa","#f59e0b","#22d3ee","#c084fc","#fb7185","#93c5fd"];
    names.forEach((n,i)=> cast[n]={photo:'',color:pal[i%pal.length]});
  }
  castGrid.innerHTML=names.map(n=>{
    const c=cast[n]||{photo:'',color:'#7aa2ff'};
    return `<div class="chip" style="margin:6px 0;">
      ${c.photo?`<img class="avatar" src="${c.photo}">`:`<div class="avatar" style="background:${c.color}">${initials(n)}</div>`}
      <div style="flex:1">${n}<input type="url" class="photoUrl" data-name="${n}" placeholder="Image URL" value="${c.photo}"></div>
      <input type="color" class="color" data-name="${n}" value="${c.color}">
    </div>`;
  }).join('');
  castGrid.querySelectorAll('.photoUrl').forEach(inp=> inp.oninput=()=>{ const n=inp.dataset.name; cast[n]=cast[n]||{photo:'',color:'#7aa2ff'}; cast[n].photo=inp.value.trim(); buildCastGrid(); });
  castGrid.querySelectorAll('.color').forEach(inp=> inp.oninput=()=>{ const n=inp.dataset.name; cast[n]=cast[n]||{photo:'',color:'#7aa2ff'}; cast[n].color=inp.value; buildCastGrid(); });
}
function buildStatsTable(){
  const names=preNames();
  statsTable.innerHTML = `<table><tr><th>Player</th><th>Social</th><th>Challenge</th></tr>${
    names.map(n=>{
      const s=stats[n]?.social??8, c=stats[n]?.challenge??8;
      return `<tr><td>${n}</td>
        <td><input type="number" class="st" data-name="${n}" data-field="social" min="1" max="15" value="${s}"></td>
        <td><input type="number" class="st" data-name="${n}" data-field="challenge" min="1" max="15" value="${c}"></td></tr>`;
    }).join('')
  }</table>`;
}
function applyStatsFromInputs(){
  statsTable.querySelectorAll('.st').forEach(inp=>{
    const n=inp.dataset.name, f=inp.dataset.field, v=clamp(parseInt(inp.value||'8',10),1,15);
    stats[n]=stats[n]||{social:8,challenge:8}; stats[n][f]=v;
  });
}
document.getElementById('applyStats').onclick=applyStatsFromInputs;
document.getElementById('presetBalanced').onclick=()=>presetStats('balanced');
document.getElementById('presetSocial').onclick=()=>presetStats('social');
document.getElementById('presetChallenge').onclick=()=>presetStats('challenge');
document.getElementById('presetRandom').onclick=()=>presetStats('random');
function presetStats(which){
  const names=preNames();
  names.forEach(n=>{
    stats[n]=stats[n]||{social:8,challenge:8};
    if(which==='balanced') stats[n]={social:8,challenge:8};
    if(which==='social')   stats[n]={social:12,challenge:8};
    if(which==='challenge')stats[n]={social:8,challenge:12};
    if(which==='random')   stats[n]={social:1+Math.floor(Math.random()*15),challenge:1+Math.floor(Math.random()*15)};
  });
  buildStatsTable();
}

/* Relationships editor */
var relFocusSel=document.getElementById('relFocus'), relEditorDiv=document.getElementById('relEditor');
function buildRelFocusList(){ const names=preNames(); relFocusSel.innerHTML=names.map(n=>`<option>${n}</option>`).join(''); if(names.length) renderRelEditorFor(names[0]); }
relFocusSel.onchange=()=> renderRelEditorFor(relFocusSel.value);
function renderRelEditorFor(focus){
  const names=preNames().filter(n=>n!==focus);
  relEditorDiv.innerHTML = `<table><tr><th>Player</th><th>Score</th></tr>${
    names.map(n=>`<tr><td>${n}</td><td><input type="number" class="relSpin" data-focus="${focus}" data-target="${n}" min="-5" max="5" step="1" value="${getRel(focus,n)}"></td></tr>`).join('')
  }</table>`;
  relEditorDiv.querySelectorAll('.relSpin').forEach(sp=> sp.oninput=()=>{ const f=sp.dataset.focus,t=sp.dataset.target; setRel(f,t,clamp(parseInt(sp.value||'0',10),-5,5)); renderRelsLive(); });
}
document.getElementById('relSave').onclick=()=>{
  relEditorDiv.querySelectorAll('.relSpin').forEach(sp=>{ const f=sp.dataset.focus,t=sp.dataset.target; setRel(f,t,clamp(parseInt(sp.value||'0',10),-5,5)); });
  const names=preNames(); names.forEach(a=>names.forEach(b=>{ if(a!==b) setRel(a,b,getRel(a,b)); }));
  queueScene('Saved all preseason relationships.'); renderRelsLive();
};
document.getElementById('relRandFocus').onclick=()=>{
  const f=relFocusSel.value; relEditorDiv.querySelectorAll('.relSpin').forEach(sp=>{ const t=sp.dataset.target; const v=Math.floor(-2+Math.random()*5); setRel(f,t,v); sp.value=v; });
  queueScene('Randomized (mild) relationships for '+f+'.'); renderRelsLive();
};
document.getElementById('relClearFocus').onclick=()=>{
  const f=relFocusSel.value; relEditorDiv.querySelectorAll('.relSpin').forEach(sp=>{ const t=sp.dataset.target; setRel(f,t,0); sp.value=0; });
  queueScene('Cleared relationships for '+f+'.'); renderRelsLive();
};
document.getElementById('relRandAll').onclick=()=>{
  const names=preNames(); for(let i=0;i<names.length;i++) for(let j=i+1;j<names.length;j++){ setRel(names[i],names[j],Math.floor(-2+Math.random()*5)); }
  queueScene('Randomized (mild) relationships for all.'); renderRelEditorFor(relFocusSel.value); renderRelsLive();
};
document.getElementById('relClearAll').onclick=()=>{
  const names=preNames(); for(let i=0;i<names.length;i++) for(let j=i+1;j<names.length;j++){ setRel(names[i],names[j],0); }
  queueScene('Cleared all preseason relationships.'); renderRelEditorFor(relFocusSel.value); renderRelsLive();
};

/* ===== Episode system ===== */
function newEpisode(title){
  const ep={title:title||('Episode '+(episodes.length+1)), scenes:[]};
  episodes.push(ep); currentEpisode=ep; sceneQueue=[]; sceneIndex=0; renderEpisodeNav();
}
function addScene(label, line){
  if(!currentEpisode) newEpisode();
  let s=currentEpisode.scenes[currentEpisode.scenes.length-1];
  if(!s || s.label!==label){ s={label:label,lines:[]}; currentEpisode.scenes.push(s); }
  s.lines.push(line); sceneQueue.push(line);
}
function queueScene(t){ sceneQueue.push(t); }
function nextSceneClick(){
  if(!sceneQueue.length){ progressGame(); return; }
  const line=sceneQueue.shift();
  sceneFeed.textContent += (sceneFeed.textContent?'\n':'') + line;
  sceneFeed.scrollTop=sceneFeed.scrollHeight;
  sceneIndex++; renderEpisodeNav();
}
function renderEpisodeNav(){
  const shown = (i)=> (spoilerFree && i===episodes.length-1)? sceneIndex : episodes[i].scenes.reduce((a,s)=>a+s.lines.length,0);
  const total = (i)=> episodes[i].scenes.reduce((a,s)=>a+s.lines.length,0);
  epListDiv.innerHTML = episodes.map((ep,i)=>`
    <div class="${(spoilerFree&&i===episodes.length-1)?'epItem spoiler':'epItem'}">
      <div class="thumb">${i+1}</div>
      <div style="flex:1">
        <input data-epi="${i}" class="epTitle" value="${ep.title}" style="width:100%;padding:6px;border-radius:8px;border:1px solid var(--border);background:var(--panel2);color:var(--text)">
        <div><small>${shown(i)} / ${total(i)} scenes</small></div>
      </div>
    </div>`).join('');
  epListDiv.querySelectorAll('.epTitle').forEach(inp=> inp.oninput=()=>{ episodes[+inp.dataset.epi].title=inp.value; });
}

/* ===== Start Season ===== */
function startSeason(){
  if(gameStarted) return;
  const input=preNames();
  if(input.length!==12){ alert('Please enter exactly 12 players.'); return; }

  players=input.slice(); initialOrder=input.slice(); knownVoters=input.slice();
  players.forEach(p=>{
    keys[p]=[]; stats[p]=stats[p]||{social:8,challenge:8}; rel[p]=rel[p]||{};
    cast[p]=cast[p]||{photo:'',color:'#7aa2ff'};
    wins[p]=0; losses[p]=0; keysEarned[p]={P1:0,P2:0}; votesGiven[p]=0; votesReceived[p]=0; juryKeysReceived[p]=0;
  });

  gameStarted=true;
  startBtn.style.display='none'; nextBtn.style.display='inline-block';

  // hide season controls + preseason editors
  document.getElementById('seasonControls').style.display='none';
  document.getElementById('castBox').style.display='none';
  document.getElementById('preseasonBox').style.display='none';

  generateAlliancesPreset();

  phase=1; round=1;
  newEpisode('Episode 1 — Phase 1 R1');
  sceneFeed.textContent='';
  queueScene('Season begins. Phase 1: The Key Quest.');
  queueScene('Alliances formed: '+Object.entries(alliances).map(e=>`${e[0]}: ${e[1].join(', ')}`).join(' | '));
  progressGame();
}

/* ===== Alliances ===== */
function presetBias(kind){
  if(kind==='loyal') return {extraSameAlliancePick:0.2, fluid:false, duo:false, loners:false};
  if(kind==='duos')  return {duo:true};
  if(kind==='loners')return {loners:true};
  return {fluid:true, extraSameAlliancePick:0.15};
}
function generateAlliancesPreset(){
  alliances={};
  const bias=presetBias(SEASON.preset);
  const labels='ABCDEFGHIJKLMNOPQRSTUVWXYZ'.slice(0, (bias.duo?6 : bias.loners?3 : 4)).split('');
  labels.forEach(k=> alliances[k]=[]);
  const sh=shuffle(players);

  if(bias.duo){
    for(let i=0;i<sh.length;i+=2){ alliances[labels[(i/2)%labels.length]].push(sh[i], sh[i+1]); }
  } else if(bias.loners){
    for(let i=0;i<sh.length;i++){ alliances[labels[i%labels.length]].push(sh[i]); }
  } else {
    for(let i=0;i<sh.length;i++){ alliances[labels[i%labels.length]].push(sh[i]); }
    if(bias.fluid){
      for(let i=0;i<players.length;i++) if(Math.random()<0.18){
        const p=players[i]; const other=labels[Math.floor(Math.random()*labels.length)];
        if(!alliances[other].includes(p)) alliances[other].push(p);
      }
    }
  }
  updateAlliances();
}

/* ===== Displays ===== */
function updateAlliances(){
  const box=document.getElementById('alliancesList');
  box.innerHTML = Object.entries(alliances).map(e=>`<div><strong>${e[0]}</strong>: ${e[1].join(', ')}</div>`).join('');
}
function updateProgress(){
  const chart=document.getElementById('progressChart');
  const everyone=players.concat(eliminated.filter(p=>!players.includes(p)));
  chart.innerHTML = `<table><tr><th>Player</th><th>P1</th><th>P2</th><th>Final</th><th>W</th><th>L</th></tr>${
    everyone.map(p=>{
      const p1=keys[p].includes('P1')?'✔':'—', p2=keys[p].includes('P2')?'✔':'—', pf=(finalists.includes(p)?'✔':'—');
      return `<tr><td>${p}</td><td>${p1}</td><td>${p2}</td><td>${pf}</td><td>${wins[p]||0}</td><td>${losses[p]||0}</td></tr>`;
    }).join('')
  }</table>`;
}
function renderRelsLive(){
  const wrap=document.getElementById('relsLive'); if(!players.length){ wrap.innerHTML=''; return; }
  const pairs=[], seen={};
  for(let i=0;i<players.length;i++)for(let j=0;j<players.length;j++){
    const a=players[i], b=players[j]; if(a===b) continue; const k=[a,b].sort().join('|'); if(seen[k]) continue; seen[k]=1;
    pairs.push({a,b,v:getRel(a,b)});
  }
  pairs.sort((x,y)=>Math.abs(y.v)-Math.abs(x.v));
  const bonds=pairs.filter(p=>p.v>0).slice(0,5), feuds=pairs.filter(p=>p.v<0).slice(0,5);
  wrap.innerHTML = `<div><strong>Bonds</strong><br/>${bonds.length?bonds.map(p=>`${p.a} ↔ ${p.b} (+${p.v})`).join('<br/>'):'<span class="hint">None</span>'}
    <hr style="border-color:var(--border)"><strong>Rivalries</strong><br/>${feuds.length?feuds.map(p=>`${p.a} ↔ ${p.b} (${p.v})`).join('<br/>'):'<span class="hint">None</span>'}</div>`;
}
function renderMasterVoteTable(){
  const wrap=document.getElementById('votingMatrix');
  let html='<div style="overflow:auto"><table><thead><tr><th>Voter</th>';
  voteColumns.forEach(c=> html+=`<th>${c.label}</th>`); html+='</tr></thead><tbody>';
  const active=players.slice(), p3=eliminated.filter(n=>getElimPhase(n)===3), p2=eliminated.filter(n=>getElimPhase(n)===2), p1=eliminated.filter(n=>getElimPhase(n)===1);
  const row=(name)=>{ html+=`<tr><td>${name}</td>`; voteColumns.forEach(c=> html+=`<td>${c.values[name]||'—'}</td>`); html+='</tr>'; };
  active.forEach(row); p3.forEach(row); p2.forEach(row); p1.forEach(row);
  html+='<tr><th>Result</th>'; voteColumns.forEach(c=> html+=`<th>${c.result||''}</th>`); html+='</tr></tbody></table></div>';
  wrap.innerHTML=html;
}
function addVoteColumn(label,phaseTag,roundNo,voters,votePairs,result,lockUser){
  const values={}; knownVoters.forEach(v=>values[v]='—');
  votePairs.forEach(([v,to])=> values[v]=to);
  if(lockUser) values[lockUser]='LOCKPICK';
  voteColumns.push({label,phaseTag,roundNo,result,values}); renderMasterVoteTable();
}

/* ===== Driver ===== */
function progressGame(){
  updateAlliances(); updateProgress(); renderRelsLive(); renderEpisodeNav();

  if(phase===1){ runPhase1(); return; }
  if(phase===2){ runPhase2(); return; }
  if(phase===3){ runPhase3(); return; }
  if(phase===4){ runFinale(); return; }
}

/* ===== Core voting ===== */
function simulateVote(voters, eligible){
  const out=[];
  voters.forEach(v=>{
    const choices=eligible.filter(p=>p!==v);
    const al=choices.filter(c=>inAlliance(v,c));
    const prioritize = al.length>0 && Math.random()<(ALLY_PREFERENCE_RATE + (SEASON.preset==='loyal'?0.2:(SEASON.preset==='fluid'?0.15:0)));
    const pool = prioritize? al : choices;
    const baseAlpha = prioritize? ALPHA_SOCIAL : 0.5*ALPHA_SOCIAL;
    const pick = weighted(pool, c=>{
      const s=(stats[c]?.social||8);
      const j=VOTE_JITTER_MIN + Math.random()*(VOTE_JITTER_MAX - VOTE_JITTER_MIN);
      return Math.pow(s,baseAlpha)*j*relFactor(v,c);
    });
    votesGiven[v]=(votesGiven[v]||0)+1; votesReceived[pick]=(votesReceived[pick]||0)+1;
    out.push([v,pick]);
  });
  return out;
}
function tally(votePairs, eligible){
  const counts={}; eligible.forEach(p=>counts[p]=0); votePairs.forEach(([_,to])=>{ if(counts[to]!=null) counts[to]++; });
  const max=Math.max(...Object.values(counts)); const tied=Object.keys(counts).filter(k=>counts[k]===max);
  return [tied[0], tied, counts];
}

/* ===== Phase 1 ===== */
function runPhase1(){
  if(p1_step===0){
    const p1Count=Object.values(keys).reduce((a,k)=>a+(k.includes?.('P1')?1:0),0);
    if(round>4 || p1Count>=8){ addScene('Phase','Phase 1 complete.'); phase=2; round=1; newEpisode('Episode '+(episodes.length+1)+' — Phase 2 R1'); return; }

    addScene('Episode', currentEpisode.title+' begins.');
    // draw
    const eligible=players.filter(p=>!keys[p].includes('P1'));
    p1_drawn=shuffle(eligible).slice(0,4);
    addScene('Draw','Drawn: '+p1_drawn.join(', '));

    // lockpick find (respect season toggle)
    if(!SEASON.noLockpick && !lockpickFound && Math.random()<0.33){
      lockpickHolder=p1_drawn[Math.floor(Math.random()*p1_drawn.length)]; lockpickFound=true;
      addScene('Find','LOCKPICK discovered by '+lockpickHolder+'.');
    }

    // vote
    p1_votePairs=simulateVote(knownVoters, p1_drawn);
    let [winner] = tally(p1_votePairs, p1_drawn);
    p1_lockUser=null;
    if(!SEASON.noLockpick && lockpickHolder && !lockpickUsed && p1_drawn.includes(lockpickHolder)){
      const mustUse=(round===4 && !keys[lockpickHolder].includes('P1'));
      if(mustUse || Math.random()<0.2){ winner=lockpickHolder; p1_lockUser=lockpickHolder; lockpickUsed=true; addScene('Lockpick', lockpickHolder+' overrides the vote.'); }
    }
    p1_winner=winner;
    addVoteColumn('P1 R'+round,'P1',round,knownVoters,p1_votePairs,p1_winner,p1_lockUser);
    addScene('Result', p1_winner+' wins the vote key.');
    keys[p1_winner].push('P1'); keysEarned[p1_winner].P1=(keysEarned[p1_winner].P1||0)+1; wins[p1_winner]=(wins[p1_winner]||0)+1;

    p1_step=1; return;
  }
  if(p1_step===1){
    const challengers=p1_drawn.filter(p=>p!==p1_winner && !keys[p].includes('P1'));
    if(challengers.length){
      p1_challengeWinner=weighted(challengers, p=>Math.pow(stats[p]?.challenge||8,BETA_CHALLENGE));
      addScene('Challenge', p1_challengeWinner+' wins the challenge key.');
      keys[p1_challengeWinner].push('P1'); keysEarned[p1_challengeWinner].P1=(keysEarned[p1_challengeWinner].P1||0)+1; wins[p1_challengeWinner]=(wins[p1_challengeWinner]||0)+1;
    } else {
      addScene('Challenge','No challenge key awarded.');
    }
    updateProgress(); renderRelsLive(); renderMasterVoteTable();
    round++; p1_step=0; newEpisode('Episode '+episodes.length+' — Phase 1 R'+round);
  }
}

/* ===== Phase 2 (single 3‑way duel if Double Duel is ON) ===== */
function runPhase2(){
  if(p2_step===0){
    const p2Count=Object.values(keys).reduce((a,k)=>a+(k.includes?.('P2')?1:0),0);
    if(round>4 || p2Count>=4){ addScene('Phase','Phase 2 complete.'); phase=3; round=1; newEpisode('Episode '+(episodes.length+1)+' — Phase 3'); return; }

    addScene('Phase','Phase 2 — Round '+round);
    p2_noKey=players.filter(p=>!keys[p].includes('P2'));
    if(p2_noKey.length<2){ addScene('Info','Not enough no‑key players. Moving to Phase 3.'); phase=3; round=1; newEpisode('Episode '+(episodes.length+1)+' — Phase 3'); return; }

    // vote winner
    p2_votePairs=simulateVote(players,p2_noKey);
    let [winner] = tally(p2_votePairs,p2_noKey);
    p2_lockUser=null;
    if(!SEASON.noLockpick && lockpickHolder && !lockpickUsed && p2_noKey.includes(lockpickHolder) && !keys[lockpickHolder].includes('P2')){
      if(Math.random()<0.6){ winner=lockpickHolder; p2_lockUser=lockpickHolder; lockpickUsed=true; addScene('Lockpick', lockpickHolder+' auto‑wins the vote.'); }
    }
    p2_winner=winner;
    addVoteColumn('P2 R'+round,'P2',round,knownVoters,p2_votePairs,p2_winner,p2_lockUser);
    addScene('Result', p2_winner+' wins the vote and will pick '+(SEASON.doubleDuel?'two opponents for a 3‑way duel.':'an opponent for a duel.'));
    p2_step=1; return;
  }

  if(p2_step===1){
    const candidates=p2_noKey.filter(p=>p!==p2_winner);
    // chooser helper
    function chooseOpponent(fromPool){
      const allies = fromPool.filter(p => inAlliance(p, p2_winner));
      const nonAllies = fromPool.filter(p => !inAlliance(p, p2_winner));
      if (allies.length && Math.random() < 0.55) {
        const pick = weighted(allies, p => 1/Math.max(1,(stats[p]?.challenge||8)) * relFactor(p2_winner,p));
        return {opp: pick, why: 'keeps key in alliance'};
      }
      if (nonAllies.length) {
        const pick = weighted(nonAllies, p => Math.pow(1/Math.max(1,(stats[p]?.challenge||8)), GAMMA_BEATABLE) * relFactor(p2_winner,p));
        return {opp: pick, why: 'chooses someone they can beat'};
      }
      const pick = weighted(fromPool, p => relFactor(p2_winner,p));
      return {opp: pick, why: 'neutral pick'};
    }

    p2_picks = [];
    let pool = candidates.slice();
    const first = chooseOpponent(pool); p2_picks.push(first); pool = pool.filter(x=>x!==first.opp);

    if(SEASON.doubleDuel && pool.length){
      const second = chooseOpponent(pool); p2_picks.push(second); pool = pool.filter(x=>x!==second.opp);
    }

    if(p2_picks.length===1){
      p2_reasonText = `${p2_picks[0].why}.`;
      addScene('Pick', `${p2_winner} chooses ${p2_picks[0].opp} — ${p2_reasonText}`);
    } else {
      p2_reasonText = `${p2_picks[0].why}; also ${p2_picks[1].why}.`;
      addScene('Pick', `${p2_winner} chooses ${p2_picks[0].opp} and ${p2_picks[1].opp} — ${p2_reasonText} They will compete in a single 3‑way duel.`);
    }

    p2_step=2; return;
  }

  if(p2_step===2){
    // Resolve duel: normal 1v1 OR 3‑way if doubleDuel
    function duel1v1(a,b){
      const p = duelWinProb(a,b);
      const winner = Math.random()<p ? a : b;
      const loser = winner===a? b : a;
      return {winner, loser};
    }
    function duel3way(a,b,c){
      // weight by challenge with a little noise
      const w = {};
      [a,b,c].forEach(x=> w[x] = (stats[x]?.challenge||8) * (0.85+Math.random()*0.3));
      const total = w[a]+w[b]+w[c];
      let r=Math.random()*total;
      if((r-=w[a])<=0) return a;
      if((r-=w[b])<=0) return b;
      return c;
    }

    if(!SEASON.doubleDuel || p2_picks.length===1){
      const a=p2_winner, b=p2_picks[0].opp;
      const r=duel1v1(a,b);
      keys[r.winner].push('P2'); keysEarned[r.winner].P2=(keysEarned[r.winner].P2||0)+1;
      wins[r.winner]=(wins[r.winner]||0)+1; losses[r.loser]=(losses[r.loser]||0)+1;
      addScene('Duel', `${r.winner} defeats ${r.loser} and earns a Phase 2 key.`);
    } else {
      const a=p2_winner, b=p2_picks[0].opp, c=p2_picks[1].opp;
      const win=duel3way(a,b,c);
      keys[win].push('P2'); keysEarned[win].P2=(keysEarned[win].P2||0)+1;
      // count one win, and one loss to each other participant
      wins[win]=(wins[win]||0)+1;
      [a,b,c].filter(x=>x!==win).forEach(l=> losses[l]=(losses[l]||0)+1);
      addScene('Duel', `${a}, ${b}, and ${c} battle in a 3‑way duel — ${win} wins the Phase 2 key.`);
    }

    updateProgress(); renderMasterVoteTable();
    round++; p2_step=0; newEpisode('Episode '+episodes.length+' — Phase 2 R'+round);
  }
}

/* ===== Phase 3 (unchanged rules + F4 ties) ===== */
function runPhase3(){
  if(p3_step===0){
    addScene('Phase','Phase 3 — Final Cut: Vote step');
    const raw=simulateVote(players,players), pairs=[];
    raw.forEach(([v,to])=>{
      if(v===to){
        const choices=players.filter(p=>p!==v);
        const pick=weighted(choices, c=> (stats[c]?.social||8) * relFactor(v,c));
        pairs.push([v,pick]);
      }else pairs.push([v,to]);
    });
    let [voteWinner] = tally(pairs,players);

    // F4 tie logic
    if(players.length===4){
      const counts={}; players.forEach(p=>counts[p]=0); pairs.forEach(([_,t])=>counts[t]++);
      const vals=Object.values(counts); const max=Math.max(...vals);
      const tiedTop=Object.keys(counts).filter(p=>counts[p]===max);
      const allEq=vals.every(v=>v===vals[0]);
      if(allEq){
        addScene('Tie','Final 4 four‑way tie! All four compete; top three advance.');
        const perf=players.map(p=>({p,score:(stats[p]?.challenge||8)*(0.8+Math.random()*0.4)})).sort((a,b)=>b.score-a.score);
        const advancing=[perf[0].p,perf[1].p,perf[2].p], fourth=perf[3].p;
        finalists=advancing.slice(); eliminated.push(fourth); jury.push({name:fourth,phase:3});
        addScene('Result','Top‑3: '+advancing.join(', ')+'. Eliminated: '+fourth+'.');
        phase=4; newEpisode('Episode '+(episodes.length+1)+' — Finale'); return;
      }
      if(tiedTop.length===2){
        const non=players.filter(p=>!tiedTop.includes(p));
        finalists=non.slice(); addScene('Tie','Final 4 two‑way tie: '+tiedTop[0]+' vs '+tiedTop[1]+'. Others advance: '+non.join(', ')+'.');
        const a=tiedTop[0], b=tiedTop[1], p=duelWinProb(a,b), dW=Math.random()<p?a:b, dL=(dW===a?b:a);
        finalists.push(dW); eliminated.push(dL); jury.push({name:dL,phase:3});
        addScene('Duel', dW+' wins tiebreak duel. '+dL+' joins the jury.');
        phase=4; newEpisode('Episode '+(episodes.length+1)+' — Finale'); return;
      }
    }

    p3_voteWinner=voteWinner; addScene('Result', voteWinner+' wins the vote and becomes a finalist.');
    const avail=players.filter(p=>p!==voteWinner);
    const ally=avail.filter(p=>inAlliance(p,voteWinner));
    p3_chosenAlly = weighted(ally.length?ally:avail, p=> (stats[p]?.social||8)*relFactor(voteWinner,p));
    addVoteColumn('P3 Vote','P3',1,knownVoters,pairs,voteWinner,null);
    p3_duelists=players.filter(p=>p!==voteWinner && p!==p3_chosenAlly);
    addScene('Pick', voteWinner+' selects '+p3_chosenAlly+'. The remaining two will duel for the last spot.');
    finalists=[p3_voteWinner,p3_chosenAlly]; p3_step=1; return;
  }
  if(p3_step===1){
    const [a,b]=p3_duelists, p=duelWinProb(a,b); const dW=Math.random()<p?a:b, dL=(dW===a?b:a);
    finalists.push(dW); eliminated.push(dL); jury.push({name:dL,phase:3});
    wins[dW]=(wins[dW]||0)+1; losses[dL]=(losses[dL]||0)+1;
    addScene('Duel', dW+' wins the final duel. '+dL+' joins the jury.');
    phase=4; p3_step=0; newEpisode('Episode '+(episodes.length+1)+' — Finale');
  }
}

/* ===== Finale (simple) ===== */
var finaleState=null, finaleStep=0;
function runFinale(){
  if(!finaleState){
    addScene('Finale','Finalists: '+finalists.join(', '));
    finaleState={ finalistKeys:{}, chosenVaults:{}, juryMatrix:{} };
    finalists.forEach(f=>finaleState.finalistKeys[f]=3);
    const support={}, maxS=finalists.reduce((m,f)=>{ let s=0; jury.forEach(j=>{ const cap=(j.phase===1?1:(j.phase===2?2:4)); if(inAlliance(j.name,f)) s+=cap; }); s+=0.4*(stats[f]?.social||8); support[f]=s; return Math.max(m,s); },1);
    const expect={}; Object.keys(support).forEach(f=> expect[f]=Math.round(6+(support[f]/maxS)*6));
    finaleState.chosenVaults=pickVaults(expect);
    finaleState.juryMatrix=distributeJuryKeys(finalists,jury,finaleState.finalistKeys);
    Object.keys(finaleState.finalistKeys).forEach(f=> juryKeysReceived[f]=(finaleState.finalistKeys[f]-3));
    displayJuryMatrix(finaleState.juryMatrix);
    addScene('Jury','Jury awards keys. Click Next Scene to reveal vault openings.');
    return;
  }
  if(finaleStep===0){
    const s=[]; finalists.forEach(f=> s.push(f+' → vault '+finaleState.chosenVaults[f]));
    addScene('Vaults','Selections: '+s.join(' | '));
    finalists.forEach(f=> addScene('Keys', f+' has '+finaleState.finalistKeys[f]+' keys.') );
    const result=finalists.map(n=>({name:n,keys:finaleState.finalistKeys[n],vault:finaleState.chosenVaults[n]})).sort((a,b)=>b.vault-a.vault);
    finaleState.winner = result.find(r=>r.keys>=r.vault) || null;
    addScene('Next','Ready to reveal winner…'); finaleStep=1; return;
  }
  if(finaleStep===1){
    if(!finaleState.winner){
      const fourth=jury.find(j=>j.phase===3)?.name || 'Fourth Place';
      addScene('Winner','No vault opens. '+fourth+' wins by default.');
    } else {
      addScene('Winner', finaleState.winner.name+' opens the '+finaleState.winner.vault+'‑key vault with '+finaleState.winner.keys+' keys and wins!');
    }
    nextBtn.textContent='Simulate Again'; nextBtn.onclick=()=>location.reload();
  }
}
function pickVaults(expect){
  const avail=vaults.slice(), picked={}, order=Object.keys(expect).sort((a,b)=>expect[b]-expect[a]);
  order.forEach(f=>{
    let best=avail[0], bestDiff=1e9, idx=0;
    for(let j=0;j<avail.length;j++){ const v=avail[j], d=Math.abs(v-expect[f]); if(d<bestDiff){ bestDiff=d; best=v; idx=j; } }
    picked[f]=best; avail.splice(idx,1);
  });
  return picked;
}
function distributeJuryKeys(finalists,jury,finalistKeys){
  const pool=[]; jury.forEach(j=>{ const cap=(j.phase===1?1:(j.phase===2?2:4)); for(let k=0;k<cap;k++) pool.push(j.name); });
  shuffle(pool).slice(0,16).forEach(jName=>{
    const base={}; finalists.forEach(f=> base[f]= (inAlliance(jName,f)?1.3:1.0) * (1 + 0.06*(stats[f]?.social||8)) );
    const pick=weighted(finalists, f=>base[f]); finalistKeys[pick]+=1;
  });
  const jm={}; jury.forEach(j=>{ jm[j.name]={}; finalists.forEach(f=> jm[j.name][f]=0); });
  const counts={}; finalists.forEach(f=>counts[f]=finalistKeys[f]-3);
  const names=Object.keys(jm); let idx=0; finalists.forEach(f=>{ for(let k=0;k<counts[f];k++){ const j=names[idx%names.length]; jm[j][f] += 1; idx++; } });
  return jm;
}

/* ===== Init preseason UIs ===== */
buildCastGrid(); buildStatsTable(); buildRelFocusList(); renderEpisodeNav();

/* ===== Jury matrix display ===== */
function displayJuryMatrix(matrix){
  const area=document.getElementById('juryMatrix'); if(!finalists.length){ area.innerHTML=''; return; }
  let html='<div style="overflow:auto"><table><tr><th>Juror</th>';
  finalists.forEach(f=> html+=`<th>${f}</th>`); html+='<th>Total</th></tr>';
  let total=0;
  for(const juror in matrix){
    let sum=0; html+=`<tr><td>${juror}</td>`;
    finalists.forEach(f=>{ const v=matrix[juror][f]||0; sum+=v; total+=v; html+=`<td>${v}</td>`; });
    html+=`<td>${sum}</td></tr>`;
  }
  html+='</table></div><div class="hint">Total jury keys: '+total+' (should be 16)</div>';
  area.innerHTML=html;
}
</script>
</body>
</html>