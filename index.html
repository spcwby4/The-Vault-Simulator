<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>The Vault Simulator</title>
  <style>
    :root{
      --bg:#0f1115;
      --panel:#1a1d24;
      --muted:#2a2f3a;
      --text:#e5e7eb;
      --sub:#aeb4c0;
      --accent:#7aa2ff;
      --good:#6ee7b7;
      --warn:#fbbf24;
      --bad:#f87171;
      --border:#2b3340;
    }
    *{box-sizing:border-box}
    body{font-family:Arial,Helvetica,sans-serif;background:var(--bg);color:var(--text);padding:20px;margin:0}
    h1{margin:0 0 16px;text-align:center}
    h2{margin:0 0 10px;font-size:18px;color:var(--text)}
    textarea,button{width:100%;padding:10px;margin-top:10px;font-size:15px;border-radius:8px;border:1px solid var(--border);background:var(--panel);color:var(--text)}
    button{cursor:pointer}
    button:hover{background:var(--muted)}
    .box{background:var(--panel);padding:15px;border-radius:12px;box-shadow:0 0 0 1px var(--border);margin-bottom:18px}
    pre{background:var(--bg);padding:10px;border-radius:8px;height:220px;overflow-y:auto;border:1px solid var(--border);white-space:pre-wrap}
    table{width:100%;border-collapse:collapse;margin-top:10px}
    th,td{border:1px solid var(--border);padding:8px;text-align:center}
    th{background:var(--muted)}
    .pill{display:inline-block;min-width:20px;border-radius:6px;padding:2px 6px}
    .ok{background:rgba(110,231,183,.15);border:1px solid rgba(110,231,183,.35)}
    .no{background:rgba(248,113,113,.12);border:1px solid rgba(248,113,113,.3)}
    details{border:1px solid var(--border);border-radius:8px;margin-top:8px}
    summary{padding:8px 10px;cursor:pointer;background:var(--muted)}
    .flex{display:flex;gap:18px;flex-wrap:wrap}
    .half{flex:1 1 420px}
    .right{max-width:520px}
    .hint{color:var(--sub);font-size:13px;margin-top:6px}
    .badge{display:inline-block;padding:2px 6px;border-radius:6px;background:var(--muted);font-size:12px;margin-left:6px}
  </style>
</head>
<body>

  <h1>The Vault Simulator <span class="badge">Dark</span></h1>

  <div class="box">
    <label for="playerInput"><strong>Enter 12 Players (one per line):</strong></label>
    <textarea id="playerInput" rows="12" placeholder="Player 1&#10;Player 2&#10;..."></textarea>
    <button id="startBtn">Start Game</button>
    <button id="nextBtn" style="display:none;">Next</button>
    <div class="hint">Flow: Phase 1 → Phase 2 → Phase 3 (vote step, then duel step) → Finale. Click Next to advance.</div>
  </div>

  <div class="flex">
    <div class="box half">
      <h2>Round Events</h2>
      <pre id="roundEvents"></pre>
    </div>

    <div class="box half right">
      <h2>Alliances</h2>
      <div id="alliancesList"></div>
    </div>
  </div>

  <div class="box">
    <h2>Progress Chart</h2>
    <div id="progressChart"></div>
  </div>

  <div class="box">
    <h2>Voting Matrix</h2>
    <div id="votingMatrix"></div>
  </div>

  <div class="box">
    <h2>Jury Key Distribution</h2>
    <div id="juryMatrix"></div>
  </div>

<script>
/* ====== State ====== */
let players = [];
let phase = 1;
let round = 1;
let alliances = {};     // {A:[...],B:[...],C:[...]}
let keys = {};          // {player:[ "P1", "P2" ]}
let jury = [];          // [{name, phase}]
let finalists = [];     // [p1,p2,p3]
let eliminated = [];
let votingHistory = []; // per-round matrices
let fullSeasonVotes = [];
let vaults = [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22];

let currentDraw = [];
let lockpickHolder = null;
let lockpickUsed = false;
let lockpickFound = false;

let gameStarted = false;
let phase3Step = 0; // 0 = vote+ally, 1 = duel

/* ====== Init / Buttons ====== */
const startBtn = document.getElementById('startBtn');
const nextBtn  = document.getElementById('nextBtn');
startBtn.onclick = startGame;
nextBtn.onclick  = nextRound;

/* ====== Helpers ====== */
function log(msg){
  const box = document.getElementById('roundEvents');
  box.textContent += (box.textContent ? '\n' : '') + msg;
  box.scrollTop = box.scrollHeight;
}
function clearLog(){ document.getElementById('roundEvents').textContent = '' }
function shuffle(arr){ return arr.slice().sort(()=>Math.random()-0.5) }
function inAlliance(a,b){
  return Object.values(alliances).some(list => list.includes(a) && list.includes(b));
}
function playerAlliance(p){
  for(const [n,list] of Object.entries(alliances)){ if(list.includes(p)) return n }
  return null;
}

/* ====== Start / Next ====== */
function startGame(){
  if(gameStarted) return;
  const input = document.getElementById('playerInput').value.trim().split('\n').map(s=>s.trim()).filter(Boolean);
  if(input.length !== 12){ alert('Please enter exactly 12 players.'); return }
  gameStarted = true;
  players = input;
  players.forEach(p => keys[p] = []);
  generateAlliances();
  updateAlliances();
  updateProgress();

  log('Phase 1 begins: The Key Quest starts now.');
  startBtn.style.display = 'none';
  nextBtn.style.display = 'inline-block';
  nextRound();
}

function nextRound(){
  clearLog();
  if(phase === 1) runPhase1();
  else if(phase === 2) runPhase2();
  else if(phase === 3) runPhase3();
  else if(phase === 4) runFinale();
}

/* ====== Voting ====== */
function simulateVote(voters, eligible){
  const pairs = voters.map(v=>{
    const choices = eligible.filter(p=>p!==v);
    const pick = choices[Math.floor(Math.random()*choices.length)];
    return [v,pick];
  });
  return pairs;
}
function tally(votePairs, eligible){
  const counts = {}; eligible.forEach(p => counts[p]=0);
  votePairs.forEach(([_,to]) => { if(counts.hasOwnProperty(to)) counts[to]++ });
  const max = Math.max(...Object.values(counts));
  const tied = Object.keys(counts).filter(p => counts[p]===max);
  return [tied[0], tied, counts];
}
function recordVotingMatrix(title, votePairs){
  // store for per-round collapsible + full season
  votingHistory.push({ title, votePairs });
  fullSeasonVotes.push(...votePairs);
  renderVotingMatrices();
}
function renderVotingMatrices(){
  const wrap = document.getElementById('votingMatrix');
  let html = '';
  votingHistory.forEach((blk, idx)=>{
    html += `<details ${idx===votingHistory.length-1?'open':''}>
      <summary>${blk.title}</summary>
      <table><tr><th>Voter</th><th>Vote</th></tr>${
        blk.votePairs.map(([v,to])=>`<tr><td>${v}</td><td>${to}</td></tr>`).join('')
      }</table>
    </details>`;
  });
  // Also show an always-updating full-season snapshot
  const all = {};
  fullSeasonVotes.forEach(([v,to])=>{
    if(!all[v]) all[v]=[];
    all[v].push(to);
  });
  html += `<details>
    <summary>Full-Season Matrix</summary>
    <table><tr><th>Voter</th><th>All Votes (in order)</th></tr>${
      Object.entries(all).map(([v,arr])=>`<tr><td>${v}</td><td>${arr.join(' → ')}</td></tr>`).join('')
    }</table>
  </details>`;
  wrap.innerHTML = html;
}

/* ====== Alliances ====== */
function generateAlliances(){
  alliances = {A:[],B:[],C:[]};
  const sh = shuffle(players);
  sh.forEach((p,i)=>{
    if(i%3===0) alliances.A.push(p);
    else if(i%3===1) alliances.B.push(p);
    else alliances.C.push(p);
  });
}
function updateAlliances(){
  const box = document.getElementById('alliancesList');
  box.innerHTML = '';
  Object.entries(alliances).forEach(([name, members])=>{
    box.innerHTML += `<strong>Alliance ${name}</strong>: ${members.join(', ')}<br/>`;
  });
}

/* ====== Progress ====== */
function updateProgress(){
  const chart = document.getElementById('progressChart');
  const everyone = players.concat(eliminated);
  let html = `<table>
    <tr><th>Player</th><th>P1</th><th>P2</th><th>Final</th></tr>`;
  everyone.forEach(p=>{
    const p1 = keys[p]?.includes('P1') ? `<span class="pill ok">✔</span>` : `<span class="pill no">—</span>`;
    const p2 = keys[p]?.includes('P2') ? `<span class="pill ok">✔</span>` : `<span class="pill no">—</span>`;
    const pf = finalists.includes(p)     ? `<span class="pill ok">✔</span>` : `<span class="pill no">—</span>`;
    html += `<tr><td>${p}</td><td>${p1}</td><td>${p2}</td><td>${pf}</td></tr>`;
  });
  html += `</table>`;
  chart.innerHTML = html;
}

/* ====== Phase 1 ====== */
function runPhase1(){
  if(round > 4 || Object.values(keys).filter(k=>k.includes('P1')).length >= 8){
    return endPhase1();
  }

  const eligible = players.filter(p=>!keys[p].includes('P1'));
  const drawn = shuffle(eligible).slice(0,4);
  currentDraw = drawn;

  log(`Phase 1 – Round ${round}`);
  log(`Drawn players: ${drawn.join(', ')}`);

  // Lockpick discovery
  if(!lockpickFound && Math.random() < 0.33){
    lockpickHolder = drawn[Math.floor(Math.random()*drawn.length)];
    lockpickFound = true;
    log(`${lockpickHolder} discovers the Lockpick.`);
  }

  // House vote among drawn (but all 12 vote)
  const votePairs = simulateVote(players, drawn);
  recordVotingMatrix(`P1 Round ${round} — House Vote`, votePairs);
  let [voteWinner, tied, counts] = tally(votePairs, drawn);

  // Smart Lockpick use in P1: auto-use in Round 4 if holder lacks P1; otherwise rarely
  if(lockpickHolder && !lockpickUsed && drawn.includes(lockpickHolder)){
    const mustUse = (round===4 && !keys[lockpickHolder].includes('P1'));
    const willUse = mustUse || Math.random() < 0.2;
    if(willUse){
      voteWinner = lockpickHolder;
      lockpickUsed = true;
      log(`${lockpickHolder} uses the Lockpick to override the vote!`);
    }
  }

  // Award vote key
  keys[voteWinner].push('P1');
  log(`${voteWinner} wins the vote key.`);

  // Challenge among remaining drawn w/out P1
  const challengers = drawn.filter(p=>p!==voteWinner && !keys[p].includes('P1'));
  if(challengers.length>0){
    const challengeWinner = challengers[Math.floor(Math.random()*challengers.length)];
    keys[challengeWinner].push('P1');
    log(`${challengeWinner} wins the challenge key.`);
  }else{
    log(`No challenge key awarded (no eligible challengers).`);
  }

  updateProgress();
  round++;
}

function endPhase1(){
  const advancing = players.filter(p=>keys[p].includes('P1'));
  const phaseOut  = players.filter(p=>!advancing.includes(p));
  eliminated = phaseOut;
  phaseOut.forEach(p=>jury.push({name:p, phase:1}));
  players = advancing;
  log(`Phase 1 complete. Eliminated: ${phaseOut.join(', ')}`);
  round = 1; phase = 2;
  nextRound();
}

/* ====== Phase 2 ====== */
function runPhase2(){
  if(round > 4 || Object.values(keys).filter(k=>k.includes('P2')).length >= 4){
    return endPhase2();
  }

  log(`Phase 2 – Round ${round}`);
  const noKey = players.filter(p=>!keys[p].includes('P2'));
  if(noKey.length < 2){
    log('Not enough no‑key players for another duel.');
    return endPhase2();
  }

  // House vote among no-key; all active players vote
  const votePairs = simulateVote(players, noKey);
  recordVotingMatrix(`P2 Round ${round} — House Vote`, votePairs);
  let [voteWinner] = tally(votePairs, noKey);

  // Smart Lockpick use in P2: if holder lacks P2 and using it would flip control
  if(lockpickHolder && !lockpickUsed && noKey.includes(lockpickHolder) && !keys[lockpickHolder].includes('P2')){
    if(Math.random() < 0.6){
      voteWinner = lockpickHolder;
      lockpickUsed = true;
      log(`${lockpickHolder} uses the Lockpick to auto‑win the vote.`);
    }
  }

  // Strategy-aware opponent selection:
  // Prefer non‑ally weak targets; sometimes keep inside alliance to ensure key stays "in the family".
  const candidates = noKey.filter(p=>p!==voteWinner);
  let nonAllies = candidates.filter(p=>!inAlliance(p, voteWinner));
  let allies    = candidates.filter(p=> inAlliance(p, voteWinner));
  let opponent;
  if(nonAllies.length && Math.random()<0.65){
    opponent = nonAllies[Math.floor(Math.random()*nonAllies.length)];
  }else if(allies.length){
    opponent = allies[Math.floor(Math.random()*allies.length)];
  }else{
    opponent = candidates[Math.floor(Math.random()*candidates.length)];
  }
  log(`${voteWinner} chooses to duel ${opponent}.`);

  const duelWinner = Math.random() < 0.5 ? voteWinner : opponent;
  keys[duelWinner].push('P2');
  log(`${duelWinner} wins the duel and earns a Phase 2 key.`);

  updateProgress();
  round++;
}

function endPhase2(){
  const advancing = players.filter(p=>keys[p].includes('P2'));
  const phaseOut  = players.filter(p=>!advancing.includes(p));
  eliminated = phaseOut;
  phaseOut.forEach(p=>jury.push({name:p, phase:2}));
  players = advancing;
  log(`Phase 2 complete. Eliminated: ${phaseOut.join(', ')}`);
  round = 1; phase = 3; phase3Step = 0;
  nextRound();
}

/* ====== Phase 3 (Two-step clickthrough) ====== */
let p3_voteWinner = null;
let p3_chosenAlly = null;
let p3_duelists = [];

function runPhase3(){
  if(phase3Step === 0){
    log(`Phase 3 – Final Cut: Vote step`);
    // All remaining players vote; cannot vote for self
    const votePairs = simulateVote(players, players);
    // Enforce no self-vote
    const cleaned = votePairs.map(([v,to])=>{
      if(v===to){
        const choices = players.filter(p=>p!==v);
        return [v, choices[Math.floor(Math.random()*choices.length)]];
      }
      return [v,to];
    });
    recordVotingMatrix(`P3 — Final Cut Vote`, cleaned);
    let [voteWinner] = tally(cleaned, players);
    p3_voteWinner = voteWinner;
    log(`${voteWinner} wins the vote and becomes a finalist.`);

    const available = players.filter(p=>p!==voteWinner);
    // Favor an ally as chosen finalist
    const allyOpts = available.filter(p=>inAlliance(p, voteWinner));
    p3_chosenAlly = (allyOpts.length ? allyOpts : available)[Math.floor(Math.random()* (allyOpts.length?allyOpts.length:available.length))];
    log(`${voteWinner} selects ${p3_chosenAlly} to join them in the finale.`);

    // Duelists are the remaining two
    p3_duelists = players.filter(p=>p!==voteWinner && p!==p3_chosenAlly);
    log(`Next: ${p3_duelists[0]} vs ${p3_duelists[1]} duel for the last spot. Click Next to resolve.`);
    // Mark finalists so far
    finalists = [p3_voteWinner, p3_chosenAlly];
    updateProgress();
    phase3Step = 1;
    return; // pause here
  }

  if(phase3Step === 1){
    const duelWinner = Math.random() < 0.5 ? p3_duelists[0] : p3_duelists[1];
    const duelLoser  = p3_duelists.find(p=>p!==duelWinner);
    finalists.push(duelWinner);
    jury.push({name:duelLoser, phase:3});
    log(`${duelWinner} wins the final duel. ${duelLoser} is eliminated and joins the jury.`);
    updateProgress();

    // Move to finale, but do not auto-run it — let user click Next
    phase = 4;
    phase3Step = 0;
    log(`Click Next to proceed to the Vault Finale.`);
  }
}

/* ====== Finale ====== */
function runFinale(){
  log(`Vault Finale — Finalists: ${finalists.join(', ')}`);

  // Each finalist starts with 3 base keys
  const finalistKeys = {};
  finalists.forEach(p => finalistKeys[p] = 3);

  // Estimate support by alliance overlap to influence vault choice and jury tendencies
  const supportScore = {};
  finalists.forEach(f=>{
    let score = 0;
    jury.forEach(j=>{
      const cap = j.phase===1?1:j.phase===2?2:4;
      if(inAlliance(j.name, f)) score += cap;
    });
    supportScore[f] = score;
  });

  // Assign unique vaults based on expected keys (close to 3 + normalized support)
  const expect = {};
  const maxSupport = Math.max(1, ...Object.values(supportScore));
  finalists.forEach(f=>{
    // heuristic expected jury keys between ~3 and ~9 depending on support
    const normalized = (supportScore[f]/maxSupport);
    expect[f] = Math.round(3 + 3 + normalized * 6); // base 3 + 3..9 jury estimate
  });

  const chosenVaults = pickUniqueVaultsForFinalists(expect);
  // Distribute exactly 16 jury keys with per-juror caps and "mostly one person" behavior
  const jm = distributeJuryKeysExact16(finalists, jury, finalistKeys);
  displayJuryMatrix(jm);

  // Determine winner: highest vault they can open
  const result = finalists.map(name => ({
    name,
    keys: finalistKeys[name],
    vault: chosenVaults[name]
  })).sort((a,b)=>b.vault - a.vault);

  let winner = result.find(r => r.keys >= r.vault);
  if(!winner){
    // If none open: 4th place (the P3 loser) wins by default
    const fourth = jury.find(j=>j.phase===3)?.name || 'Fourth Place';
    log(`No finalist opened a vault. ${fourth} wins by default!`);
  }else{
    log(`${winner.name} opens the ${winner.vault}-key vault with ${winner.keys} keys and wins!`);
  }
}

/* Unique vaults closest to expectations, no duplicates */
function pickUniqueVaultsForFinalists(expect){
  const picked = {};
  const available = vaults.slice();
  // Sort finalists by expected keys high → low to give first pick to the perceived front‑runner
  const order = Object.keys(expect).sort((a,b)=>expect[b]-expect[a]);
  order.forEach(f=>{
    let best = available[0], bestDiff = Infinity, bestIdx = 0;
    available.forEach((v,i)=>{
      const d = Math.abs(v - expect[f]);
      if(d < bestDiff){ bestDiff = d; best = v; bestIdx = i; }
    });
    picked[f] = best;
    available.splice(bestIdx, 1);
  });
  log(`Vault choices (based on expectations): ${order.map(f=>`${f} → ${picked[f]}`).join(', ')}`);
  return picked;
}

/* Jury distribution that totals EXACTLY 16 keys with per-juror caps.
   Behavior: jurors usually dump all keys on one finalist, unless they share alliances with multiple finalists. */
function distributeJuryKeysExact16(finalists, jury, finalistKeys){
  // Build a "cap pool": each juror appears as many times as they can give
  const capPool = [];
  const caps = {};
  jury.forEach(j=>{
    const cap = j.phase===1?1:j.phase===2?2:4;
    caps[j.name] = cap;
    for(let i=0;i<cap;i++) capPool.push(j.name);
  });

  // Take exactly 16 draws (or fewer if not enough capacity)
  shuffle(capPool);
  const draws = capPool.slice(0,16);

  // For each draw, pick a recipient finalist using alliance‑first, then “respect” logic
  const jm = {};
  jury.forEach(j=>{ jm[j.name] = Object.fromEntries(finalists.map(f=>[f,0])) });

  draws.forEach(jName=>{
    const j = jury.find(x=>x.name===jName);
    const shared = finalists.filter(f=>inAlliance(j.name, f));
    let target;
    if(shared.length === 1){
      // almost always give to the one shared ally
      target = shared[0];
    }else if(shared.length === 2){
      // if shares with both finalists, slight bias to the one with higher expected support
      const bias = Math.random() < 0.6 ? finalists.slice().sort((a,b)=>expectedSupport(b)-expectedSupport(a))[0]
                                        : finalists[Math.floor(Math.random()*finalists.length)];
      target = bias;
    }else{
      // no shared alliance: pick the perceived front‑runner ~65% of the time
      target = Math.random() < 0.65 ? finalists.slice().sort((a,b)=>expectedSupport(b)-expectedSupport(a))[0]
                                    : finalists[Math.floor(Math.random()*finalists.length)];
    }
    jm[jName][target] += 1;
    finalistKeys[target] += 1;
  });

  return jm;

  function expectedSupport(f){
    // proxy: number of jurors sharing alliance weighted by cap
    let s = 0;
    jury.forEach(j=>{
      const cap = j.phase===1?1:j.phase===2?2:4;
      if(inAlliance(j.name, f)) s += cap;
    });
    return s;
  }
}

/* ====== UI: Jury Matrix ====== */
function displayJuryMatrix(matrix){
  const area = document.getElementById('juryMatrix');
  if(!finalists.length){ area.innerHTML = ''; return }
  let html = `<table><tr><th>Juror</th>${finalists.map(f=>`<th>${f}</th>`).join('')}<th>Total</th></tr>`;
  let totalGiven = 0;
  for(const juror in matrix){
    let sum = 0;
    html += `<tr><td>${juror}</td>`;
    finalists.forEach(f=>{
      const v = matrix[juror][f]||0;
      sum += v; totalGiven += v;
      html += `<td>${v}</td>`;
    });
    html += `<td>${sum}</td></tr>`;
  }
  html += `</table>`;
  html += `<div class="hint">Total jury keys distributed: <strong>${totalGiven}</strong> (should be exactly 16)</div>`;
  area.innerHTML = html;
}

/* ====== Wire up ====== */
updateProgress();
</script>

</body>
</html>