<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>The Vault Simulator</title>
  <style>
    body { font-family: Arial; background: #f2f2f2; padding: 20px; }
    h1 { text-align: center; }
    textarea, button { width: 100%; padding: 10px; margin-top: 10px; font-size: 16px; }
    .box { background: white; padding: 15px; border-radius: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.1); margin-bottom: 20px; }
    pre { background: #eee; padding: 10px; border-radius: 5px; height: 200px; overflow-y: scroll; }
    table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: center; }
    .collapsible { background-color: #eee; cursor: pointer; padding: 10px; width: 100%; text-align: left; border: none; outline: none; font-size: 16px; margin-top: 5px; }
    .collapsible.active, .collapsible:hover { background-color: #ccc; }
    .content { display: none; overflow: hidden; padding: 0 10px 10px; }
  </style>
</head>
<body>

  <h1>The Vault Simulator</h1>

  <div class="box">
    <label for="playerInput"><strong>Enter 12 Players (one per line):</strong></label>
    <textarea id="playerInput" rows="12" placeholder="Player 1&#10;Player 2&#10;..."></textarea>
    <button onclick="startGame()">Start Game</button>
  </div>

  <div class="box" id="alliancesBox">
    <h2>Alliances</h2>
    <div id="alliancesList"></div>
  </div>

  <div class="box">
    <h2>Round Events</h2>
    <pre id="roundEvents"></pre>
  </div>

  <div class="box">
    <h2>Progress Chart</h2>
    <div id="progressChart"></div>
  </div>

  <div class="box">
    <h2>Voting Matrix</h2>
    <div id="votingMatrix"></div>
  </div>

  <div class="box">
    <h2>Jury Key Distribution</h2>
    <div id="juryMatrix"></div>
  </div>

  <script>
let players = [], round = 0, phase = 1, phase1Keys = 0, lockpickHolder = null;
let eliminated = [], finalists = [], juryVotes = [], voteLogs = [];

function startGame() {
  const input = document.getElementById('playerInput').value.trim().split('\n').map(x => x.trim()).filter(x => x);
  if (input.length !== 12) return alert("Please enter exactly 12 players.");
  players = input.map(name => ({ name, key1: false, key2: false, key3: false, eliminated: false }));
  createAlliances();
  showAlliances();
  log(`🗝️ Key Quest Begins!`);
  simulatePhase1();
}

function simulatePhase1() {
  if (phase1Keys >= 8) {
    log(`Phase 1 complete. Eliminating players without a key...`);
    players.forEach(p => {
      if (!p.key1) {
        p.eliminated = true;
        eliminated.push({ name: p.name, phase: 1 });
      }
    });
    players = players.filter(p => !p.eliminated);
    phase = 2;
    round = 0;
    log(`🔓 Phase 2 begins with ${players.length} players.`);
    simulatePhase2();
    return;
  }

  round++;
  log(`🔹 Round ${round} Draw`);
  const eligible = players.filter(p => !p.key1);
  const drawn = sample(eligible, Math.min(4, eligible.length));
  log(`Drawn: ${drawn.map(p => p.name).join(', ')}`);

  // Lockpick chance
  if (!lockpickHolder && Math.random() < 0.33) {
    const finder = sample(drawn);
    lockpickHolder = finder.name;
    log(`🔑 ${finder.name} discovered the Lockpick!`);
  }

  const votes = players.map(p => {
    let options = drawn.filter(d => d.name !== p.name);
    return { voter: p.name, vote: sample(options).name };
  });

  const counts = {};
  votes.forEach(v => counts[v.vote] = (counts[v.vote] || 0) + 1);
  const voteWinner = Object.entries(counts).sort((a,b) => b[1]-a[1])[0][0];

  if (lockpickHolder && sample(drawn).name === lockpickHolder) {
    log(`${lockpickHolder} uses the Lockpick to win the vote!`);
    voteWinnerFinal = lockpickHolder;
    lockpickHolder = null;
  } else {
    log(`🏛️ ${voteWinner} wins the vote.`);
  }

  const voteWinnerObj = drawn.find(p => p.name === voteWinner);
  if (voteWinnerObj) {
    voteWinnerObj.key1 = true;
    phase1Keys++;
  }

  const remaining = drawn.filter(p => p.name !== voteWinner);
  const challengeWinner = sample(remaining);
  log(`🏆 ${challengeWinner.name} wins the challenge.`);
  challengeWinner.key1 = true;
  phase1Keys++;

  voteLogs.push({ phase: 1, round, votes });

  setTimeout(simulatePhase1, 800);
}

function simulatePhase2() {
  round++;
  if (round > 4) {
    log(`Phase 2 complete. Eliminating players without a Phase 2 key...`);
    players.forEach(p => {
      if (!p.key2) {
        p.eliminated = true;
        eliminated.push({ name: p.name, phase: 2 });
      }
    });
    players = players.filter(p => !p.eliminated);
    phase = 3;
    round = 0;
    simulatePhase3();
    return;
  }

  log(`🔸 Phase 2 - Round ${round}`);
  const noKey = players.filter(p => !p.key2);
  const votes = players.map(p => {
    let options = noKey.filter(n => n.name !== p.name);
    return { voter: p.name, vote: sample(options).name };
  });

  const counts = {};
  votes.forEach(v => counts[v.vote] = (counts[v.vote] || 0) + 1);
  const voteWinner = Object.entries(counts).sort((a,b) => b[1]-a[1])[0][0];
  let voteWinnerObj = noKey.find(p => p.name === voteWinner);

  if (lockpickHolder && noKey.find(p => p.name === lockpickHolder)) {
    log(`${lockpickHolder} uses the Lockpick to force a duel.`);
    voteWinnerObj = players.find(p => p.name === lockpickHolder);
    lockpickHolder = null;
  }

  const opponent = sample(noKey.filter(p => p.name !== voteWinnerObj.name));
  const duelWinner = sample([voteWinnerObj, opponent]);
  duelWinner.key2 = true;
  log(`⚔️ Duel: ${voteWinnerObj.name} vs ${opponent.name}. ${duelWinner.name} wins the key!`);

  voteLogs.push({ phase: 2, round, votes });

  setTimeout(simulatePhase2, 800);
}

function simulatePhase3() {
  round++;
  if (round > 1) {
    log(`Final 3 determined.`);
    simulateFinale();
    return;
  }

  log(`🔻 Phase 3 - Final 4 Vote`);
  const votes = players.map(p => {
    let options = players.filter(o => o.name !== p.name);
    return { voter: p.name, vote: sample(options).name };
  });

  const counts = {};
  votes.forEach(v => counts[v.vote] = (counts[v.vote] || 0) + 1);
  const sorted = Object.entries(counts).sort((a,b) => b[1]-a[1]);
  const top = sorted[0][0], topObj = players.find(p => p.name === top);
  topObj.key3 = true;
  log(`🏛️ ${topObj.name} wins the vote and auto-advances to the finale.`);

  const picked = sample(players.filter(p => p.name !== top));
  picked.key3 = true;
  log(`${topObj.name} brings ${picked.name} to the finale.`);

  const remaining = players.filter(p => p.name !== top && p.name !== picked.name);
  const challengeWinner = sample(remaining);
  challengeWinner.key3 = true;
  log(`🏆 ${challengeWinner.name} wins the final challenge and joins the finale.`);

  const eliminatedPlayer = remaining.find(p => p.name !== challengeWinner.name);
  eliminatedPlayer.eliminated = true;
  eliminated.push({ name: eliminatedPlayer.name, phase: 3 });

  finalists = [topObj, picked, challengeWinner];
  voteLogs.push({ phase: 3, round, votes });

  simulateFinale();
}

function simulateFinale() {
  log(`🔒 The Vault Finale Begins...`);
  const vaults = [12, 14, 16, 18, 20, 22];
  shuffleArray(vaults);
  finalists.forEach((p, i) => p.vault = vaults[i]);

  let juryMatrix = [];
  eliminated.forEach(e => {
    const keys = e.phase === 1 ? 1 : e.phase === 2 ? 2 : 4;
    for (let i = 0; i < keys; i++) {
      const pick = sample(finalists);
      pick.bonus = (pick.bonus || 0) + 1;
      juryMatrix.push({ juror: e.name, vote: pick.name });
    }
  });

  finalists.forEach(p => {
    p.total = 3 + (p.bonus || 0);
    log(`${p.name} selected vault ${p.vault}. Total keys: ${p.total}`);
  });

  const openers = finalists.filter(p => p.total >= p.vault);
  if (openers.length === 0) {
    const backup = eliminated.find(e => e.phase === 3);
    log(`No vaults opened. ${backup.name} wins by default!`);
  } else {
    const winner = openers.reduce((a,b) => a.vault > b.vault ? a : b);
    log(`🏆 ${winner.name} opens the highest vault and wins the game!`);
  }

  updateProgressChart();
  updateVotingMatrix();
  updateJuryMatrix(juryMatrix);
}

function sample(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

function log(msg) {
  const box = document.getElementById('roundEvents');
  box.innerHTML += msg + '\n';
}

function updateProgressChart() {
  let html = `<table><tr><th>Player</th><th>Phase 1</th><th>Phase 2</th><th>Phase 3</th></tr>`;
  [...players, ...eliminated].forEach(p => {
    html += `<tr><td>${p.name}</td><td>${p.key1 ? '✅' : ''}</td><td>${p.key2 ? '✅' : ''}</td><td>${p.key3 ? '✅' : ''}</td></tr>`;
  });
  html += `</table>`;
  document.getElementById('progressChart').innerHTML = html;
}

function updateVotingMatrix() {
  let html = '';
  voteLogs.forEach(r => {
    html += `<button class="collapsible">Phase ${r.phase}, Round ${r.round}</button><div class="content"><table><tr><th>Voter</th><th>Voted For</th></tr>`;
    r.votes.forEach(v => html += `<tr><td>${v.voter}</td><td>${v.vote}</td></tr>`);
    html += `</table></div>`;
  });
  document.getElementById('votingMatrix').innerHTML = html;
  setupCollapsibles();
}

function updateJuryMatrix(juryData) {
  let html = `<table><tr><th>Juror</th><th>Vote</th></tr>`;
  juryData.forEach(j => html += `<tr><td>${j.juror}</td><td>${j.vote}</td></tr>`);
  html += `</table>`;
  document.getElementById('juryMatrix').innerHTML = html;
}

function createAlliances() {
  const names = ['The Untucked Dolls', 'Pretty Problematic', 'Team Talent'];
  const pool = [...players];
  shuffleArray(pool);
  alliances = {
    'The Untucked Dolls': pool.slice(0, 4).map(p => p.name),
    'Pretty Problematic': pool.slice(4, 8).map(p => p.name),
    'Team Talent': pool.slice(8, 12).map(p => p.name)
  };
}

function showAlliances() {
  let html = '';
  for (let group in alliances) {
    html += `<b>${group}</b>: ${alliances[group].join(', ')}<br>`;
  }
  document.getElementById('alliancesList').innerHTML = html;
}

function setupCollapsibles() {
  document.querySelectorAll('.collapsible').forEach(btn => {
    btn.onclick = function () {
      this.classList.toggle("active");
      const content = this.nextElementSibling;
      content.style.display = content.style.display === "block" ? "none" : "block";
    };
  });
}
  </script>

</body>
</html>