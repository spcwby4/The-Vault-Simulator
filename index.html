<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>The Vault Simulator</title>
  <style>
    :root{
      --bg:#0f1115;
      --panel:#1a1d24;
      --muted:#2a2f3a;
      --text:#e5e7eb;
      --sub:#aeb4c0;
      --accent:#7aa2ff;
      --good:#6ee7b7;
      --warn:#fbbf24;
      --bad:#f87171;
      --border:#2b3340;
    }
    *{box-sizing:border-box}
    body{font-family:Arial,Helvetica,sans-serif;background:var(--bg);color:var(--text);padding:20px;margin:0}
    h1{margin:0 0 16px;text-align:center}
    h2{margin:0 0 10px;font-size:18px;color:var(--text)}
    textarea,button{width:100%;padding:10px;margin-top:10px;font-size:15px;border-radius:8px;border:1px solid var(--border);background:var(--panel);color:var(--text)}
    button{cursor:pointer}
    button:hover{background:var(--muted)}
    .box{background:var(--panel);padding:15px;border-radius:12px;box-shadow:0 0 0 1px var(--border);margin-bottom:18px}
    pre{background:var(--bg);padding:10px;border-radius:8px;height:220px;overflow-y:auto;border:1px solid var(--border);white-space:pre-wrap}
    table{width:100%;border-collapse:collapse;margin-top:10px}
    th,td{border:1px solid var(--border);padding:8px;text-align:center;white-space:nowrap}
    th{background:var(--muted);position:sticky;top:0}
    .pill{display:inline-block;min-width:20px;border-radius:6px;padding:2px 6px}
    .ok{background:rgba(110,231,183,.15);border:1px solid rgba(110,231,183,.35)}
    .no{background:rgba(248,113,113,.12);border:1px solid rgba(248,113,113,.3)}
    .flex{display:flex;gap:18px;flex-wrap:wrap}
    .half{flex:1 1 420px}
    .right{max-width:520px}
    .hint{color:var(--sub);font-size:13px;margin-top:6px}
    .badge{display:inline-block;padding:2px 6px;border-radius:6px;background:var(--muted);font-size:12px;margin-left:6px}
    .table-scroll{overflow:auto;max-width:100%}
  </style>
</head>
<body>

  <h1>The Vault Simulator <span class="badge">Dark</span></h1>

  <div class="box">
    <label for="playerInput"><strong>Enter 12 Players (one per line):</strong></label>
    <textarea id="playerInput" rows="12" placeholder="Player 1&#10;Player 2&#10;..."></textarea>
    <button id="startBtn">Start Game</button>
    <button id="nextBtn" style="display:none;">Next</button>
    <div class="hint">Flow: Phase 1 → Phase 2 → Phase 3 (vote step, then duel step) → Finale (Jury → Open → Winner).</div>
  </div>

  <div class="flex">
    <div class="box half">
      <h2>Round Events</h2>
      <pre id="roundEvents"></pre>
    </div>

    <div class="box half right">
      <h2>Alliances</h2>
      <div id="alliancesList"></div>
    </div>
  </div>

  <div class="box">
    <h2>Progress Chart</h2>
    <div id="progressChart"></div>
  </div>

  <div class="box">
    <h2>Voting Matrix (Season)</h2>
    <div class="table-scroll" id="votingMatrix"></div>
    <div class="hint">Plain text. LOCKPICK appears in the voter’s cell if used that round. Eliminated voters are kept and moved to the bottom.</div>
  </div>

  <div class="box">
    <h2>Jury Key Distribution</h2>
    <div id="juryMatrix"></div>
  </div>

<script>
/* ====== State ====== */
let players = [];
let initialOrder = [];
let phase = 1;
let round = 1;

let alliances = {};     // {Name:[players]}
let keys = {};          // {player:[ "P1", "P2" ]}
let jury = [];          // [{name, phase}]
let finalists = [];     // [p1,p2,p3]
let eliminated = [];    // elimination order

let lockpickHolder = null;
let lockpickUsed = false;
let lockpickFound = false;

let currentDraw = [];

let voteColumns = [];   // [{label, phaseTag, roundNo, result, values:{voter:value}}]
let knownVoters = [];
let vaults = [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22];

let gameStarted = false;
let phase3Step = 0; // 0 vote+ally, 1 duel

// Finale staged flow
let finaleStep = 0; // 0 jury awards, 1 open vaults, 2 reveal winner
let finaleState = {
  finalistKeys: null,
  chosenVaults: null,
  juryMatrix: null,
  resultList: null,
  winner: null,
};

const startBtn = document.getElementById('startBtn');
const nextBtn  = document.getElementById('nextBtn');
const roundsBox= document.getElementById('roundEvents');

startBtn.onclick = startGame;
nextBtn.onclick  = nextRound;

/* ====== Helpers ====== */
function log(msg){
  roundsBox.textContent += (roundsBox.textContent ? '\n' : '') + msg;
  roundsBox.scrollTop = roundsBox.scrollHeight;
}
function clearLog(){ roundsBox.textContent = '' }
function shuffle(arr){ return arr.slice().sort(()=>Math.random()-0.5) }
function inAlliance(a,b){
  return Object.values(alliances).some(list => list.includes(a) && list.includes(b));
}
function allianceNamesFor(p){
  return Object.entries(alliances).filter(([n,list])=>list.includes(p)).map(([n])=>n);
}
function getElimPhase(name){
  const j = jury.find(x=>x.name===name);
  return j ? j.phase : null;
}

/* ====== Start / Next / Reset ====== */
function startGame(){
  if(gameStarted) return;
  const input = document.getElementById('playerInput').value.trim().split('\n').map(s=>s.trim()).filter(Boolean);
  if(input.length !== 12){ alert('Please enter exactly 12 players.'); return }
  gameStarted = true;

  players = input;
  initialOrder = input.slice();
  knownVoters = input.slice();
  players.forEach(p => keys[p] = []);

  generateAlliances();
  updateAlliances();
  updateProgress();
  renderMasterVoteTable();

  log('Phase 1 begins: The Key Quest starts now.');
  startBtn.style.display = 'none';
  nextBtn.style.display = 'inline-block';
  nextBtn.textContent = 'Next';
  nextBtn.onclick = nextRound;

  nextRound();
}

function nextRound(){
  clearLog();
  if(phase === 1) runPhase1();
  else if(phase === 2) runPhase2();
  else if(phase === 3) runPhase3();
  else if(phase === 4) runFinale();
}

function endGameUI(){
  nextBtn.textContent = 'Simulate Again';
  nextBtn.onclick = ()=>location.reload();
}

/* ====== Voting Core ====== */
function simulateVote(voters, eligible){
  // secret voting, slight ally bias when possible
  return voters.map(v=>{
    const choices = eligible.filter(p=>p!==v);
    const allyChoices = choices.filter(c=>inAlliance(v,c));
    const pick = allyChoices.length && Math.random()<0.6
      ? allyChoices[Math.floor(Math.random()*allyChoices.length)]
      : choices[Math.floor(Math.random()*choices.length)];
    return [v,pick];
  });
}
function tally(votePairs, eligible){
  const counts = {}; eligible.forEach(p => counts[p]=0);
  votePairs.forEach(([_,to]) => { if(counts.hasOwnProperty(to)) counts[to]++ });
  const max = Math.max(...Object.values(counts));
  const tied = Object.keys(counts).filter(p => counts[p]===max);
  return [tied[0], tied, counts];
}

/* Season voting chart */
function addVoteColumn(label, phaseTag, roundNo, voters, votePairs, result, lockpickUser=null){
  const values = {};
  knownVoters.forEach(v => values[v] = '—');
  votePairs.forEach(([v,to]) => { values[v] = to });
  if(lockpickUser){ values[lockpickUser] = 'LOCKPICK' }
  voteColumns.push({label, phaseTag, roundNo, result, values});
  renderMasterVoteTable();
}

function renderMasterVoteTable(){
  const wrap = document.getElementById('votingMatrix');
  let html = `<div class="table-scroll"><table><thead><tr><th>Voter</th>`;
  voteColumns.forEach(c => { html += `<th>${c.label}</th>`; });
  html += `</tr></thead><tbody>`;

  // Order rows: finalists (active) → Phase 3 eliminated → Phase 2 eliminated → Phase 1 eliminated
  const activeRows = players.slice(); // finalists are the remaining active at endgame, but this updates each phase
  const elimP3 = eliminated.filter(n=>getElimPhase(n)===3);
  const elimP2 = eliminated.filter(n=>getElimPhase(n)===2);
  const elimP1 = eliminated.filter(n=>getElimPhase(n)===1);

  function renderRow(name){
    html += `<tr><td>${name}</td>`;
    voteColumns.forEach(c=>{
      html += `<td>${c.values[name] ?? '—'}</td>`;
    });
    html += `</tr>`;
  }

  activeRows.forEach(renderRow);
  elimP3.forEach(renderRow);
  elimP2.forEach(renderRow);
  elimP1.forEach(renderRow);

  // result row
  html += `<tr><th>Result</th>`;
  voteColumns.forEach(c => { html += `<th>${c.result || ''}</th>`; });
  html += `</tr>`;

  html += `</tbody></table></div>`;
  wrap.innerHTML = html;
}

/* ====== Alliances (fluid, secret voting respected) ====== */
function generateAlliances(){
  alliances = {};
  const count = Math.floor(Math.random()*3)+2; // 2..4 alliances
  const names = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('').slice(0,count);
  const sh = shuffle(players);

  names.forEach(n => alliances[n] = []);
  sh.forEach((p,i)=> alliances[names[i%count]].push(p));

  // small chance of dual-membership at start
  players.forEach(p=>{
    if(Math.random()<0.15){
      const other = names[Math.floor(Math.random()*names.length)];
      if(!alliances[other].includes(p)) alliances[other].push(p);
    }
  });
}

function penalizeNonAllyDuel(decider, opponent){
  // If decider had at least one ally available but chose a non-ally, 50% chance to be kicked from one alliance
  const decAlliances = Object.entries(alliances).filter(([_,list])=>list.includes(decider)).map(([n])=>n);
  if(!decAlliances.length) return;

  if(!inAlliance(decider, opponent)){
    // they picked a non-ally; check if any ally existed among candidates (handled by caller)
    if(Math.random() < 0.5){
      const kickFrom = decAlliances[Math.floor(Math.random()*decAlliances.length)];
      const arr = alliances[kickFrom];
      const idx = arr.indexOf(decider);
      if(idx>-1){
        arr.splice(idx,1);
        log(`${decider} is removed from Alliance ${kickFrom} for not choosing an ally to duel.`);
        updateAlliances();
      }
    }
  }
}

// No voting-based kicks. Just occasional new alliance formation.
function evolveAlliancesMidgame(){
  if(Math.random()<0.25 && players.length>=4){
    const size = Math.floor(Math.random()*3)+2; // 2..4
    const cand = shuffle(players).slice(0, size);
    const newName = pickNewAllianceName();
    alliances[newName] = cand.slice();
    log(`New Alliance ${newName} forms: ${cand.join(', ')}`);
    updateAlliances();
  }
}

function pickNewAllianceName(){
  const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
  for(const c of alphabet){
    if(!alliances[c]) return c;
  }
  return 'Z'+Math.floor(Math.random()*99);
}
function updateAlliances(){
  const box = document.getElementById("alliancesList");
  box.innerHTML = '';
  Object.entries(alliances).forEach(([name, members])=>{
    // filter out fully eliminated members from display
    const visible = members.filter(m => initialOrder.includes(m));
    if(visible.length){
      box.innerHTML += `<strong>Alliance ${name}</strong>: ${visible.join(', ')}<br/>`;
    }
  });
}

/* ====== Progress (keep eliminated at bottom) ====== */
function updateProgress(){
  const chart = document.getElementById('progressChart');
  const everyone = players
    .concat(eliminated.filter(p=>!players.includes(p)));
  let html = `<div class="table-scroll"><table>
    <tr><th>Player</th><th>P1</th><th>P2</th><th>Final</th></tr>`;
  everyone.forEach(p=>{
    const p1 = keys[p]?.includes('P1') ? `<span class="pill ok">✔</span>` : `<span class="pill no">—</span>`;
    const p2 = keys[p]?.includes('P2') ? `<span class="pill ok">✔</span>` : `<span class="pill no">—</span>`;
    const pf = finalists.includes(p)     ? `<span class="pill ok">✔</span>` : `<span class="pill no">—</span>`;
    html += `<tr><td>${p}</td><td>${p1}</td><td>${p2}</td><td>${pf}</td></tr>`;
  });
  html += `</table></div>`;
  chart.innerHTML = html;
}

/* ====== Phase 1 ====== */
function runPhase1(){
  if(round > 4 || Object.values(keys).filter(k=>k.includes('P1')).length >= 8){
    return endPhase1();
  }

  const eligible = players.filter(p=>!keys[p].includes('P1'));
  const drawn = shuffle(eligible).slice(0,4);
  currentDraw = drawn;

  log(`Phase 1 – Round ${round}`);
  log(`Drawn: ${drawn.join(', ')}`);

  if(!lockpickFound && Math.random() < 0.33){
    lockpickHolder = drawn[Math.floor(Math.random()*drawn.length)];
    lockpickFound = true;
    log(`${lockpickHolder} discovers the Lockpick.`);
  }

  const votePairs = simulateVote(knownVoters, drawn);
  let [voteWinner] = tally(votePairs, drawn);

  let lockUser = null;
  if(lockpickHolder && !lockpickUsed && drawn.includes(lockpickHolder)){
    const mustUse = (round===4 && !keys[lockpickHolder].includes('P1'));
    const willUse = mustUse || Math.random() < 0.2;
    if(willUse){
      voteWinner = lockpickHolder;
      lockUser = lockpickHolder;
      lockpickUsed = true;
      log(`${lockpickHolder} uses the Lockpick to override the vote.`);
    }
  }

  addVoteColumn(`P1 R${round}`, 'P1', round, knownVoters, votePairs, voteWinner, lockUser);

  keys[voteWinner].push('P1');
  log(`${voteWinner} wins the vote key.`);

  const challengers = drawn.filter(p=>p!==voteWinner && !keys[p].includes('P1'));
  if(challengers.length>0){
    const challengeWinner = challengers[Math.floor(Math.random()*challengers.length)];
    keys[challengeWinner].push('P1');
    log(`${challengeWinner} wins the challenge key.`);
  }else{
    log(`No challenge key awarded.`);
  }

  evolveAlliancesMidgame();
  updateProgress();
  round++;
}

function endPhase1(){
  const advancing = players.filter(p=>keys[p].includes('P1'));
  const phaseOut  = players.filter(p=>!advancing.includes(p));

  phaseOut.forEach(p=>{ if(!eliminated.includes(p)) eliminated.push(p) });
  phaseOut.forEach(p=>jury.push({name:p, phase:1}));

  players = advancing;
  log(`Phase 1 complete. Eliminated: ${phaseOut.join(', ')}`);
  renderMasterVoteTable();
  round = 1; phase = 2;
  nextRound();
}

/* ====== Phase 2 ====== */
function runPhase2(){
  if(round > 4 || Object.values(keys).filter(k=>k.includes('P2')).length >= 4){
    return endPhase2();
  }

  log(`Phase 2 – Round ${round}`);
  const noKey = players.filter(p=>!keys[p].includes('P2'));
  if(noKey.length < 2){
    log('Not enough no‑key players for another duel.');
    return endPhase2();
  }

  const votePairs = simulateVote(players, noKey);
  let [voteWinner] = tally(votePairs, noKey);

  let lockUser = null;
  if(lockpickHolder && !lockpickUsed && noKey.includes(lockpickHolder) && !keys[lockpickHolder].includes('P2')){
    if(Math.random() < 0.6){
      voteWinner = lockpickHolder;
      lockUser = lockpickHolder;
      lockpickUsed = true;
      log(`${lockpickHolder} uses the Lockpick to auto‑win the vote.`);
    }
  }

  addVoteColumn(`P2 R${round}`, 'P2', round, knownVoters, votePairs, voteWinner, lockUser);

  // Opponent choice with reason
  const candidates = noKey.filter(p=>p!==voteWinner);
  const nonAllies = candidates.filter(p=>!inAlliance(p, voteWinner));
  const allies    = candidates.filter(p=> inAlliance(p, voteWinner));

  let opponent, reason;
  let choseNonAllyWhenAlliesExist = false;

  if(nonAllies.length && Math.random()<0.65){
    opponent = nonAllies[Math.floor(Math.random()*nonAllies.length)];
    reason = 'chooses someone they believe they can beat';
    if(allies.length) choseNonAllyWhenAlliesExist = true;
  }else if(allies.length){
    opponent = allies[Math.floor(Math.random()*allies.length)];
    reason = 'keeps the key within their alliance';
  }else{
    opponent = candidates[Math.floor(Math.random()*candidates.length)];
    reason = 'makes a neutral pick';
  }
  log(`${voteWinner} chooses to duel ${opponent} — ${reason}.`);

  // Penalize for not choosing an ally to duel (secret voting respected)
  if(choseNonAllyWhenAlliesExist){
    penalizeNonAllyDuel(voteWinner, opponent);
  }

  const duelWinner = Math.random() < 0.5 ? voteWinner : opponent;
  keys[duelWinner].push('P2');
  log(`${duelWinner} wins the duel and earns a Phase 2 key.`);

  evolveAlliancesMidgame();
  updateProgress();
  round++;
}

function endPhase2(){
  const advancing = players.filter(p=>keys[p].includes('P2'));
  const phaseOut  = players.filter(p=>!advancing.includes(p));

  phaseOut.forEach(p=>{ if(!eliminated.includes(p)) eliminated.push(p) });
  phaseOut.forEach(p=>jury.push({name:p, phase:2}));

  players = advancing;
  log(`Phase 2 complete. Eliminated: ${phaseOut.join(', ')}`);
  renderMasterVoteTable();
  round = 1; phase = 3; phase3Step = 0;
  nextRound();
}

/* ====== Phase 3 (Two-step) ====== */
let p3_voteWinner = null;
let p3_chosenAlly = null;
let p3_duelists = [];

function runPhase3(){
  if(phase3Step === 0){
    log(`Phase 3 — Final Cut: Vote step`);
    const votePairsRaw = simulateVote(players, players);
    const votePairs = votePairsRaw.map(([v,to])=>{
      if(v===to){
        const choices = players.filter(p=>p!==v);
        return [v, choices[Math.floor(Math.random()*choices.length)]];
      }
      return [v,to];
    });
    let [voteWinner] = tally(votePairs, players);
    p3_voteWinner = voteWinner;
    log(`${voteWinner} wins the vote and becomes a finalist.`);

    const available = players.filter(p=>p!==voteWinner);
    const allyOpts = available.filter(p=>inAlliance(p, voteWinner));
    p3_chosenAlly = (allyOpts.length ? allyOpts : available)[Math.floor(Math.random()* (allyOpts.length?allyOpts.length:available.length))];
    log(`${voteWinner} selects ${p3_chosenAlly} to join them in the finale.`);

    addVoteColumn(`P3 Vote`, 'P3', 1, knownVoters, votePairs, voteWinner, null);

    p3_duelists = players.filter(p=>p!==voteWinner && p!==p3_chosenAlly);
    log(`Next: ${p3_duelists[0]} vs ${p3_duelists[1]} duel for the last spot. Click Next to resolve.`);
    finalists = [p3_voteWinner, p3_chosenAlly];
    updateProgress();
    phase3Step = 1;
    return;
  }

  if(phase3Step === 1){
    const duelWinner = Math.random() < 0.5 ? p3_duelists[0] : p3_duelists[1];
    const duelLoser  = p3_duelists.find(p=>p!==duelWinner);
    finalists.push(duelWinner);
    if(!eliminated.includes(duelLoser)) eliminated.push(duelLoser);
    jury.push({name:duelLoser, phase:3});
    log(`${duelWinner} wins the final duel. ${duelLoser} is eliminated and joins the jury.`);
    updateProgress();

    phase = 4;
    phase3Step = 0;
    log(`Click Next to proceed to the Vault Finale.`);
  }
}

/* ====== Finale (3 screens: Jury → Open → Winner) ====== */
function runFinale(){
  if(finaleStep === 0){
    // Setup state only once
    if(!finaleState.finalistKeys){
      finaleState.finalistKeys = {};
      finalists.forEach(p => finaleState.finalistKeys[p] = 3);

      // Support score to guide vault choices
      const supportScore = {};
      finalists.forEach(f=>{
        let score = 0;
        jury.forEach(j=>{
          const cap = j.phase===1?1:j.phase===2?2:4;
          if(inAlliance(j.name, f)) score += cap;
        });
        supportScore[f] = score;
      });

      const expect = {};
      const maxSupport = Math.max(1, ...Object.values(supportScore));
      finalists.forEach(f=>{
        const normalized = (supportScore[f]/maxSupport);
        expect[f] = Math.round(6 + normalized * 6); // 6..12 expected
      });

      finaleState.chosenVaults = pickUniqueVaultsForFinalists(expect);

      // Distribute exactly 16 jury keys
      finaleState.juryMatrix = distributeJuryKeysExact16(finalists, jury, finaleState.finalistKeys);
    }

    log(`Vault Finale — Jury awards keys now.`);
    displayJuryMatrix(finaleState.juryMatrix);
    log(`Click Next to reveal vault openings.`);
    finaleStep = 1;
    return;
  }

  if(finaleStep === 1){
    // Reveal each finalist's keys vs their vault
    log(`Vault selections: ${finalists.map(f=>`${f} → ${finaleState.chosenVaults[f]} keys`).join(', ')}`);
    finalists.forEach(f=>{
      log(`${f} has ${finaleState.finalistKeys[f]} total keys.`);
    });

    // Prepare result list and winner, but do not reveal yet
    const result = finalists.map(name => ({
      name,
      keys: finaleState.finalistKeys[name],
      vault: finaleState.chosenVaults[name]
    })).sort((a,b)=>b.vault - a.vault);
    finaleState.resultList = result;
    finaleState.winner = result.find(r => r.keys >= r.vault) || null;

    log(`Click Next to reveal the winner.`);
    finaleStep = 2;
    return;
  }

  if(finaleStep === 2){
    if(!finaleState.winner){
      const fourth = jury.find(j=>j.phase===3)?.name || 'Fourth Place';
      log(`No finalist opened a vault. ${fourth} wins by default.`);
    }else{
      log(`${finaleState.winner.name} opens the ${finaleState.winner.vault}-key vault with ${finaleState.winner.keys} keys and wins.`);
    }
    endGameUI();
  }
}

/* Unique vaults closest to expectations, no duplicates */
function pickUniqueVaultsForFinalists(expect){
  const picked = {};
  const available = vaults.slice();
  const order = Object.keys(expect).sort((a,b)=>expect[b]-expect[a]);
  order.forEach(f=>{
    let best = available[0], bestDiff = Infinity, bestIdx = 0;
    available.forEach((v,i)=>{
      const d = Math.abs(v - expect[f]);
      if(d < bestDiff){ bestDiff = d; best = v; bestIdx = i; }
    });
    picked[f] = best;
    available.splice(bestIdx, 1);
  });
  return picked;
}

/* Jury distribution to total EXACTLY 16 keys with per-juror caps. */
function distributeJuryKeysExact16(finalists, jury, finalistKeys){
  const capPool = [];
  jury.forEach(j=>{
    const cap = j.phase===1?1:j.phase===2?2:4;
    for(let i=0;i<cap;i++) capPool.push(j.name);
  });
  shuffle(capPool);
  const draws = capPool.slice(0,16);

  const jm = {};
  jury.forEach(j=>{ jm[j.name] = Object.fromEntries(finalists.map(f=>[f,0])) });

  draws.forEach(jName=>{
    const j = jury.find(x=>x.name===jName);
    const shared = finalists.filter(f=>inAlliance(j.name, f));
    let target;
    if(shared.length === 1){
      target = shared[0];
    }else if(shared.length === 2){
      target = Math.random()<0.6 ? finalists.slice().sort((a,b)=>expectedSupport(b)-expectedSupport(a))[0]
                                 : finalists[Math.floor(Math.random()*finalists.length)];
    }else{
      target = Math.random()<0.65 ? finalists.slice().sort((a,b)=>expectedSupport(b)-expectedSupport(a))[0]
                                  : finalists[Math.floor(Math.random()*finalists.length)];
    }
    jm[jName][target] += 1;
    finalistKeys[target] += 1;
  });

  return jm;

  function expectedSupport(f){
    let s = 0;
    jury.forEach(j=>{
      const cap = j.phase===1?1:j.phase===2?2:4;
      if(inAlliance(j.name, f)) s += cap;
    });
    return s;
  }
}

/* ====== UI: Jury Matrix ====== */
function displayJuryMatrix(matrix){
  const area = document.getElementById('juryMatrix');
  if(!finalists.length){ area.innerHTML = ''; return }
  let html = `<div class="table-scroll"><table><tr><th>Juror</th>${finalists.map(f=>`<th>${f}</th>`).join('')}<th>Total</th></tr>`;
  let totalGiven = 0;
  for(const juror in matrix){
    let sum = 0;
    html += `<tr><td>${juror}</td>`;
    finalists.forEach(f=>{
      const v = matrix[juror][f]||0;
      sum += v; totalGiven += v;
      html += `<td>${v}</td>`;
    });
    html += `<td>${sum}</td></tr>`;
  }
  html += `</table></div>`;
  html += `<div class="hint">Total jury keys distributed: <strong>${totalGiven}</strong> (should be exactly 16)</div>`;
  area.innerHTML = html;
}

/* ====== Wire up ====== */
updateProgress();

</script>
</body>
</html>