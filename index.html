// The Vault Simulator - Full HTML and JavaScript Logic

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>The Vault Simulator</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; background: #f0f0f0; }
    textarea, button { display: block; margin: 10px 0; width: 100%; max-width: 400px; }
    table, th, td { border: 1px solid #aaa; border-collapse: collapse; padding: 5px; text-align: center; }
    .highlight { background-color: yellow; }
  </style>
</head>
<body>
  <h1>The Vault Simulator</h1>
  <textarea id="playerInput" rows="12" placeholder="Enter 12 player names, one per line"></textarea>
  <button id="startBtn" onclick="startGame()">Start Game</button>
  <button id="nextBtn" style="display:none" onclick="runRound()">Run Next Round</button>

  <div id="log"></div>
  <div id="progressTable"></div>
  <div id="votingChart"></div>

  <script>
// Basic setup
let players = [], phase = 1, round = 1, lockpickHolder = null, eliminated = [], finalists = [], jury = [],
  vaults = Array.from({length: 20}, (_, i) => i + 3), alliances = {}, voteLogs = [], finaleComplete = false;

function startGame() {
  const input = document.getElementById("playerInput").value.trim().split("\n").map(p => p.trim()).filter(Boolean);
  if (input.length !== 12) return alert("Please enter exactly 12 player names.");
  players = input.map(name => ({ name, key1: false, key2: false, key3: false, totalKeys: 0, eliminated: false, alliance: [], vault: null, bonusKeys: 0, totalFinalKeys: 0 }));
  assignAlliances();
  logAlliances();
  document.getElementById("startBtn").style.display = "none";
  document.getElementById("nextBtn").style.display = "inline-block";
  runRound();
}

function assignAlliances() {
  const total = Math.floor(Math.random() * 6) + 1;
  for (let i = 1; i <= total; i++) {
    const members = shuffle(players).slice(0, Math.floor(Math.random() * 4) + 2);
    alliances[`Alliance ${i}`] = members.map(p => p.name);
    members.forEach(m => m.alliance.push(`Alliance ${i}`));
  }
}

function logAlliances() {
  let text = "<b>Alliances:</b><br>";
  for (let a in alliances) text += `${a}: ${alliances[a].join(", ")}<br>`;
  document.getElementById("log").innerHTML += text;
}

function runRound() {
  clearLog();
  logAlliances();
  if (finaleComplete) return;
  if (phase === 1) runPhase1();
  else if (phase === 2) runPhase2();
  else if (phase === 3) runPhase3();
  else if (phase === 4) runFinale();
}

function runPhase1() {
  const eligible = players.filter(p => !p.key1 && !p.eliminated);
  if (round > 4) {
    players.forEach(p => { if (!p.key1) p.eliminated = true, eliminated.push(p); });
    phase = 2; round = 1; lockpickHolder = null; return runRound();
  }
  const drawn = shuffle(eligible).slice(0, 4);
  log(`Phase 1 - Round ${round}`);
  log(`Drawn: ${drawn.map(p => p.name).join(", ")}`);
  if (!lockpickHolder && Math.random() < 0.33) lockpickHolder = drawn[Math.floor(Math.random() * drawn.length)], log(`${lockpickHolder.name} found the Lockpick!`);
  let voteWinner = (lockpickHolder && drawn.includes(lockpickHolder)) ? lockpickHolder : drawn[Math.floor(Math.random() * drawn.length)];
  if (lockpickHolder === voteWinner) lockpickHolder = null, log(`${voteWinner.name} uses the Lockpick to win the vote key.`);
  else log(`${voteWinner.name} wins the vote key.`);
  voteWinner.key1 = true; voteWinner.totalKeys++;
  let challengers = drawn.filter(p => p !== voteWinner);
  let challengeWinner = challengers[Math.floor(Math.random() * challengers.length)];
  challengeWinner.key1 = true; challengeWinner.totalKeys++;
  log(`${challengeWinner.name} wins the challenge key.`);
  voteLogs.push({ phase: 1, round, vote: `${voteWinner.name}`, challenge: `${challengeWinner.name}` });
  round++;
  updateTable();
}

function runPhase2() {
  const noKey = players.filter(p => !p.key2 && !p.eliminated);
  if (round > 4 || noKey.length < 2) {
    players.forEach(p => { if (!p.key2 && !p.eliminated) p.eliminated = true, eliminated.push(p); });
    phase = 3; round = 1; return runRound();
  }
  log(`Phase 2 - Round ${round}`);
  const votes = {}, voters = players.filter(p => !p.eliminated);
  for (let v of voters) {
    let choices = noKey.filter(p => p.name !== v.name);
    let choice = pickAllyOrRandom(v, choices);
    votes[choice.name] = (votes[choice.name] || 0) + 1;
  }
  let winnerName = Object.entries(votes).sort((a,b)=>b[1]-a[1])[0][0];
  let voteWinner = noKey.find(p => p.name === winnerName);
  if (lockpickHolder) voteWinner = lockpickHolder, lockpickHolder = null, log(`${voteWinner.name} uses the Lockpick to override the vote.`);
  else log(`${voteWinner.name} wins the vote.`);
  let duelChoices = noKey.filter(p => p.name !== voteWinner.name);
  let opponent = pickAllyOrRandom(voteWinner, duelChoices);
  log(`${voteWinner.name} selects ${opponent.name} to duel.`);
  let duelWinner = Math.random() < 0.5 ? voteWinner : opponent;
  duelWinner.key2 = true; duelWinner.totalKeys++;
  log(`${duelWinner.name} wins the duel.`);
  voteLogs.push({ phase: 2, round, vote: `${voteWinner.name}`, opponent: `${opponent.name}`, winner: `${duelWinner.name}` });
  round++;
  updateTable();
}

function runPhase3() {
  const active = players.filter(p => !p.eliminated && p.key1 && p.key2);
  if (active.length !== 4) return log("Phase 3 requires exactly 4 players.");
  log(`Phase 3 - Final 4 Voting`);
  const votes = {}, roundVotes = {};
  for (let v of active) {
    const choices = active.filter(p => p.name !== v.name);
    let voteFor = pickAllyOrRandom(v, choices);
    votes[voteFor.name] = (votes[voteFor.name] || 0) + 1;
    roundVotes[v.name] = voteFor.name;
  }
  voteLogs.push({ phase: 3, round: 1, votes: roundVotes });
  const sorted = Object.entries(votes).sort((a,b)=>b[1]-a[1]);
  if (sorted.length > 1 && sorted[0][1] === sorted[1][1]) {
    const tied = sorted.slice(0,2).map(e=>e[0]);
    const untied = active.filter(p => !tied.includes(p.name));
    const duelWinner = tied[Math.floor(Math.random()*2)];
    finalists = [...untied, active.find(p => p.name === duelWinner)];
    log(`${untied.map(p=>p.name).join(" and ")} move on. ${duelWinner} wins the tie-break duel.`);
  } else {
    const winner = sorted[0][0];
    const voteWinner = active.find(p => p.name === winner);
    const others = active.filter(p => p.name !== winner);
    const chosen = pickAllyOrRandom(voteWinner, others);
    const duelists = others.filter(p => p !== chosen);
    const duelWinner = duelists[Math.floor(Math.random() * 2)];
    finalists = [voteWinner, chosen, duelWinner];
    log(`${voteWinner.name} brings ${chosen.name}. ${duelWinner.name} wins the final duel.`);
  }
  players.forEach(p => { if (!finalists.includes(p)) p.eliminated = true, jury.push(p); else p.key3 = true; });
  phase = 4;
  round = 1;
  updateTable();
}

function runFinale() {
  log(`Vault Finale`);
  for (let f of finalists) {
    f.totalFinalKeys = 3;
    let est = f.totalKeys + 3;
    let options = vaults.filter(v => v >= est - 1 && v <= est + 3);
    f.vault = options[Math.floor(Math.random() * options.length)] || 3;
    log(`${f.name} chooses to try and unlock the ${f.vault}-key vault.`);
  }
const totalJuryKeys = 16;
for (let i = 0; i < totalJuryKeys; i++) {
  const juror = jury[i % jury.length];
  const recipient = pickAllyOrRandom(juror, finalists);
  recipient.bonusKeys++;
  recipient.totalFinalKeys++;
}
  let unlocked = finalists.filter(f => f.totalFinalKeys >= f.vault);
  if (unlocked.length) {
    unlocked.sort((a,b)=>b.vault - a.vault);
    log(`${unlocked[0].name} unlocks the highest vault and wins!`);
  } else {
    log(`${finalists[0].name} wins by default, no vaults opened.`);
  }
  finaleComplete = true;
  generateVotingChart();
}

function pickAllyOrRandom(voter, choices) {
  const allies = choices.filter(c => c.alliance.some(a => voter.alliance.includes(a)));
  return allies.length ? allies[Math.floor(Math.random() * allies.length)] : choices[Math.floor(Math.random() * choices.length)];
}

function updateTable() {
  let html = "<table><tr><th>Player</th><th>P1</th><th>P2</th><th>P3</th><th>Total</th></tr>";
  for (let p of players) {
    if (p.eliminated && !finalists.includes(p)) continue;
    html += `<tr><td>${p.name}</td><td${p.key1 ? ' class="highlight"' : ''}>${p.key1 ? 'âœ…' : ''}</td><td${p.key2 ? ' class="highlight"' : ''}>${p.key2 ? 'âœ…' : ''}</td><td${p.key3 ? ' class="highlight"' : ''}>${p.key3 ? 'âœ…' : ''}</td><td>${p.totalFinalKeys || p.totalKeys}</td></tr>`;
  }
  html += "</table>";
  document.getElementById("progressTable").innerHTML = html;
}

function generateVotingChart() {
  let chart = "<h2>Voting Chart</h2><table><tr><th>Player</th>";
  let maxPhase = Math.max(...voteLogs.map(v => v.phase));
  for (let r = 1; r <= 9; r++) chart += `<th>R${r}</th>`;
  chart += "<th>Jury Keys</th></tr>";
  let sorted = [...players].sort((a,b)=>b.totalFinalKeys - a.totalFinalKeys);
  for (let p of sorted) {
    chart += `<tr><td>${p.name}</td>`;
    for (let r = 1; r <= 9; r++) {
      const log = voteLogs.find(v => v.round === r && (v.vote === p.name || (v.votes && Object.values(v.votes).includes(p.name))));
      chart += `<td>${log ? 'ðŸ”·' : ''}</td>`;
    }
    chart += `<td>${p.bonusKeys || 0}</td></tr>`;
  }
  chart += "</table>";
  document.getElementById("votingChart").innerHTML = chart;
}

function log(msg) {
  document.getElementById("log").innerHTML += msg + "<br>";
}

function clearLog() {
  document.getElementById("log").innerHTML = "";
}

function shuffle(arr) {
  return arr.slice().sort(() => Math.random() - 0.5);
}

  </script>
</body>
</html>